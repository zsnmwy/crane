<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Crane – 提案</title><link>/zh-cn/docs/proposals/</link><description>Recent content in 提案 on Crane</description><generator>Hugo -- gohugo.io</generator><atom:link href="/zh-cn/docs/proposals/index.xml" rel="self" type="application/rss+xml"/><item><title>Docs: Advanced CPUSet Manager</title><link>/zh-cn/docs/proposals/20220228-advanced-cpuset-manger/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/zh-cn/docs/proposals/20220228-advanced-cpuset-manger/</guid><description>
&lt;p>Static CPU manager is supported by kubelet, when a guaranteed Pod is running on a node, kubelet allocate specific cpu cores to the processes exclusively, which generally keeps the cpu utilization of the node low.
This proposal provides a new mechanism to manage cpusets, which allows sharing cpu cores with other processes while binds cpuset.It also allows to revise cpuset when pod is running and relaxes restrictions of binding cpus in kubelet.&lt;/p>
&lt;h2 id="table-of-contents">Table of Contents&lt;/h2>
&lt;!-- TOC -->
&lt;ul>
&lt;li>&lt;a href="#advanced-cpuset-manager">Advanced CPUSet Manager&lt;/a>
&lt;ul>
&lt;li>&lt;a href="#table-of-contents">Table of Contents&lt;/a>&lt;/li>
&lt;li>&lt;a href="#motivation">Motivation&lt;/a>
&lt;ul>
&lt;li>&lt;a href="#goals">Goals&lt;/a>&lt;/li>
&lt;li>&lt;a href="#non-goalsfuture-work">Non-Goals/Future Work&lt;/a>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;a href="#proposal">Proposal&lt;/a>
&lt;ul>
&lt;li>&lt;a href="#relax-restrictions-of-cpuset-allocation">Relax restrictions of cpuset allocation&lt;/a>&lt;/li>
&lt;li>&lt;a href="#add-new-annotation-to-describe-the--requirement-of-cpuset-contorl-manger">Add new annotation to describe the requirement of cpuset contorl manger&lt;/a>&lt;/li>
&lt;li>&lt;a href="#advanced-cpu-manager-component">Advanced CPU Manager component&lt;/a>&lt;/li>
&lt;li>&lt;a href="#user-stories">User Stories&lt;/a>
&lt;ul>
&lt;li>&lt;a href="#story-1">Story 1&lt;/a>&lt;/li>
&lt;li>&lt;a href="#story-2">Story 2&lt;/a>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;a href="#risks-and-mitigations">Risks and Mitigations&lt;/a>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;!-- /TOC -->
&lt;h2 id="motivation">Motivation&lt;/h2>
&lt;p>Some latency-sensitive applications have lower lantency and cpu usage when running with specific cores, which results in fewer context switches and higer cache affinity.
But kubelet will always exclude assigned cores in shared cores, which may waste resources.Offline and other online pods can running on the cores actually. In our experiment, for the most part, it is barely noticeable for performance of service.&lt;/p>
&lt;h3 id="goals">Goals&lt;/h3>
&lt;ul>
&lt;li>Provide a new mechanism to manage cpuset bypass&lt;/li>
&lt;li>Provide a new cpuset manager method &amp;ldquo;shared&amp;rdquo;&lt;/li>
&lt;li>Allow revise cpuset when pod running&lt;/li>
&lt;li>Relax restrictions of binding cpus&lt;/li>
&lt;/ul>
&lt;h3 id="non-goalsfuture-work">Non-Goals/Future Work&lt;/h3>
&lt;ul>
&lt;li>Solve the conflicts with kubelet static cpuset manager, you need to set kubelet cpuset manager to &amp;ldquo;none&amp;rdquo;&lt;/li>
&lt;li>Numa manager will support in future, CCX/CCD manager also be considered&lt;/li>
&lt;/ul>
&lt;h2 id="proposal">Proposal&lt;/h2>
&lt;h3 id="relax-restrictions-of-cpuset-allocation">Relax restrictions of cpuset allocation&lt;/h3>
&lt;p>Kubelet allocate cpus for containers should meet the conditions:&lt;/p>
&lt;ol>
&lt;li>
&lt;p>requests and limits are specified for all the containers and they are equal&lt;/p>
&lt;/li>
&lt;li>
&lt;p>the container&amp;rsquo;s resource limit for the limit of CPU is an integer greater than or equal to one and equal to request request of CPU.&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p>In Crane, only need to meet condition No.2&lt;/p>
&lt;h3 id="add-new-annotation-to-describe-the--requirement-of-cpuset-contorl-manger">Add new annotation to describe the requirement of cpuset contorl manger&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-yaml" data-lang="yaml">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">apiVersion&lt;/span>: &lt;span style="color:#ae81ff">v1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">kind&lt;/span>: &lt;span style="color:#ae81ff">Pod&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">metadata&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">annotations&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">qos.gocrane.io/cpu-manager&lt;/span>: &lt;span style="color:#ae81ff">none/exclusive/share&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Provide three polices for cpuset manager:&lt;/p>
&lt;ul>
&lt;li>none: containers of this pod shares a set of cpus which not allocated to exclusive containers&lt;/li>
&lt;li>exclusive: containers of this pod monopolize the allocated CPUs , other containers not allowed to use.&lt;/li>
&lt;li>share: containers of this pod runs in theallocated CPUs , but other containers can also use.&lt;/li>
&lt;/ul>
&lt;h3 id="advanced-cpu-manager-component">Advanced CPU Manager component&lt;/h3>
&lt;p>&lt;img src="/images/advanced_cpuset_manager.png" alt="advanced_cpuset_manager.png">&lt;/p>
&lt;ul>
&lt;li>Crane-agent use podLister informs to sense the creation of pod.&lt;/li>
&lt;li>Crane-agent allocate cpus when pod is binded, and loop in cycle to addContainer(change cpuset) until the containers are created&lt;/li>
&lt;li>Update/Delete pod will handle in reconcile state.&lt;/li>
&lt;li>state.State referenced from kubelet and topology_cpu_assignment copied from kubelet&lt;/li>
&lt;/ul>
&lt;h3 id="user-stories">User Stories&lt;/h3>
&lt;ul>
&lt;li>Users can update pod annotaion to control cpuset policy flexibly&lt;/li>
&lt;/ul>
&lt;h4 id="story-1">Story 1&lt;/h4>
&lt;p>make pod from none to share without recreating pod&lt;/p>
&lt;h4 id="story-2">Story 2&lt;/h4>
&lt;p>make pod from exclusive to share, so offline process can use these CPUs&lt;/p>
&lt;h3 id="risks-and-mitigations">Risks and Mitigations&lt;/h3>
&lt;ul>
&lt;li>kubelet cpu manger policy need to be set to none, otherwise will be conflicted with crane-agent&lt;/li>
&lt;li>if crane-agent can not allocate CPUs for pods, it will not refuse to start pod as kubelet&lt;/li>
&lt;/ul></description></item><item><title>Docs: Provide a policy-based abnormal detection mechanism in crane-agent</title><link>/zh-cn/docs/proposals/20220402-policy-based-abnomal-detection/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/zh-cn/docs/proposals/20220402-policy-based-abnomal-detection/</guid><description>
&lt;h2 id="summary">Summary&lt;/h2>
&lt;p>Crane-agent is responsible for detecting abnormality on nodes and interference between running pods.&lt;/p>
&lt;p>Currently, such detection mechanism is fixed and quite simple.
Crane-agent compares the values of some pre-defined metrics, such as node&amp;rsquo;s &lt;code>cpu_total_usage&lt;/code> and &lt;code>cpu_total_utilization&lt;/code>,
with some thresholds periodically. If the metric value is higher the threshold for some times, say the &lt;code>cpu_total_utilization&lt;/code>
on a node is found higher than 80% in 3 consecutive detections, crane-agent thinks the node entering into an abnormal status,
and will perform some further actions, such as suppressing or evicting pods with low priorities.&lt;/p>
&lt;p>This proposal suggests a flexible and extensible way to detect abnormality. The criteria of abnormality can be customized by
users in form of policies, and the detection process is executed in a policy decision-making way, which is offloaded to a
general-purpose policy engine.&lt;/p>
&lt;h2 id="motivation">Motivation&lt;/h2>
&lt;p>The criteria of abnormality or interference are not that always as simple as something like a metric value is higher than a threshold.
Different users may have different QOS requirements on different applications in different environments. The rule of
abnormality detection varies, and it is impossible to implement all of them in code in advance.&lt;/p>
&lt;h3 id="goals">Goals&lt;/h3>
&lt;ol>
&lt;li>Provides an abnormality detection mechanism which can consume external metrics.&lt;/li>
&lt;li>Provides an abnormality detection mechanism in which the logic determining how to check the abnormality can be customized.&lt;/li>
&lt;li>Metrics and detection policies can be added, updated and deleted on the fly without changing the code.&lt;/li>
&lt;/ol>
&lt;h3 id="non-goals">Non-Goals&lt;/h3>
&lt;ol>
&lt;li>How to handle the abnormality or interference. This proposal only focuses on detection, and the subsequent action is
out of scope.&lt;/li>
&lt;/ol>
&lt;h2 id="proposal">Proposal&lt;/h2>
&lt;h3 id="user-stories">User Stories&lt;/h3>
&lt;h4 id="story-1">Story 1&lt;/h4>
&lt;p>A user has a critical online application which is latency sensitive running in the cluster, and he wants to use both
the 99th percentile response time and the error code rate as the application QOS indicators. If either of these 2 indicators
deteriorates, the application is thought of being in abnormal status.&lt;/p>
&lt;h4 id="story-2">Story 2&lt;/h4>
&lt;p>The SRE team finds that if the node CPU utilization is more than 60%, the QOS of some latency sensitive applications
running on it are likely to decline. So they want to keep the node CPU utilization lower than 60%.
If the utilization is higher than this threshold, the BE applications should be suppressed
accordingly.&lt;/p>
&lt;h4 id="story-3">Story 3&lt;/h4>
&lt;p>The traffic of online applications is very low at night, and the offline jobs are run during this time.
Comparing with online applications, offline jobs always require more CPU resource quantities but less resource qualities.
In this case, the SRE team wants to set different node CPU load thresholds in the daytime and at night.&lt;/p>
&lt;h3 id="functional-requirements">Functional Requirements&lt;/h3>
&lt;h3 id="implementation-details">Implementation Details&lt;/h3>
&lt;h4 id="api">API&lt;/h4>
&lt;p>#####NodeQOSEnsurancePolicy&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-yaml" data-lang="yaml">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">apiVersion&lt;/span>: &lt;span style="color:#ae81ff">ensurance.crane.io/v1alpha1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">kind&lt;/span>: &lt;span style="color:#ae81ff">NodeQOSEnsurancePolicy&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">metadata&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">name&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;xxx&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">spec&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">nodeQualityProbe&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">prometheus&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">targets&lt;/span>: [&lt;span style="color:#e6db74">&amp;#39;localhost:9090&amp;#39;&lt;/span>]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">queryInterval&lt;/span>: &lt;span style="color:#ae81ff">60s&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">metrics&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#f92672">name&lt;/span>: &lt;span style="color:#ae81ff">node_cpu_utilization&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">query&lt;/span>: &lt;span style="color:#ae81ff">1&lt;/span> - &lt;span style="color:#ae81ff">avg(irate(node_cpu_seconds_total{mode=&amp;#34;idle&amp;#34;, instance=&amp;#34;$nodeName&amp;#34;}[5m]))&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">variables&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#f92672">name&lt;/span>: &lt;span style="color:#ae81ff">nodeName&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">valueFrom&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">fieldRef&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">fieldPath&lt;/span>: &lt;span style="color:#ae81ff">spec.nodeName&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">objectiveEnsurances&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#f92672">name&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;ext_cpu_total_distribute&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">avoidanceThreshold&lt;/span>: &lt;span style="color:#ae81ff">2&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">restoreThreshold&lt;/span>: &lt;span style="color:#ae81ff">2&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">actionName&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;disablescheduling&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">policy&lt;/span>: |&lt;span style="color:#e6db74">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> default abnormal = false
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> hour := time.clock([time.now_ns(), &amp;#34;Local&amp;#34;])[0]
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> abnormal {
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> input.node_cpu_utilization &amp;gt; 0.6
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> hour &amp;gt;= 7, hour &amp;lt; 21
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> }
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> abnormal {
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> input.node_cpu_utilization &amp;gt; 0.8
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> hour &amp;gt;= 21
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> }
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> abnormal {
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> input.node_cpu_utilization &amp;gt; 0.8
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> hour &amp;lt; 7
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> }&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>#####PodQOSEnsurancePolicy&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-yaml" data-lang="yaml">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">apiVersion&lt;/span>: &lt;span style="color:#ae81ff">ensurance.crane.io/v1alpha1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">kind&lt;/span>: &lt;span style="color:#ae81ff">PodQOSEnsurancePolicy&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">metadata&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">name&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;xxx&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">spec&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">selector&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">matchLabels&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">app&lt;/span>: &lt;span style="color:#ae81ff">test&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">qualityProbe&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">prometheus&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">targets&lt;/span>: [&lt;span style="color:#e6db74">&amp;#39;localhost:9090&amp;#39;&lt;/span>]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">queryInterval&lt;/span>: &lt;span style="color:#ae81ff">60s&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">metrics&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#f92672">name&lt;/span>: &lt;span style="color:#ae81ff">test_app_p90_latency&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">query&lt;/span>: &lt;span style="color:#ae81ff">histogram_quantile(0.9, rate(http_request_duration_seconds_bucket{pod=~&amp;#34;$podName&amp;#34;, node=&amp;#34;$nodeName&amp;#34;}[1m]))&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">variables&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#f92672">name&lt;/span>: &lt;span style="color:#ae81ff">podName&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">valueFrom&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">fieldRef&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">fieldPath&lt;/span>: &lt;span style="color:#ae81ff">metadata.name&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#f92672">name&lt;/span>: &lt;span style="color:#ae81ff">nodeName&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">valueFrom&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">fieldRef&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">fieldPath&lt;/span>: &lt;span style="color:#ae81ff">spec.nodeName&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">objectiveEnsurances&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#f92672">name&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;ext_cpu_total_distribute&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">avoidanceThreshold&lt;/span>: &lt;span style="color:#ae81ff">2&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">restoreThreshold&lt;/span>: &lt;span style="color:#ae81ff">2&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">actionName&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;disablescheduling&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">policy&lt;/span>: |&lt;span style="color:#e6db74">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> &lt;/span> &lt;span style="color:#ae81ff">abnormal if test_app_p90_latency[_].value &amp;gt; 0.1&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>In addition to &lt;code>Prometheus&lt;/code>, other protocols, such as &lt;code>Graphite&lt;/code>, &lt;code>InfluxDB&lt;/code> can also
be added in the future.&lt;/p>
&lt;h4 id="metrics">Metrics&lt;/h4>
&lt;h4 id="built-in-metrics">Built-in metrics&lt;/h4>
&lt;p>Currently, crane-agent collects a bunch of metrics(defined in &lt;code>pkg/ensurance/collector/types/types.go&lt;/code>, e.g.
&lt;code>cpu_total_usage&lt;/code>).
These metrics are collected by &lt;code>nodelocal&lt;/code> and &lt;code>cadvisor&lt;/code> collectors, both of which collects metrics every 10 seconds.&lt;/p>
&lt;p>We call these metrics as built-in metrics. Users can use built-in metrics in the policy without explicit setting, and
crane-agent will pass their values to every request to policy engine.&lt;/p>
&lt;h5 id="external-metrics-new">External metrics (New)&lt;/h5>
&lt;p>Crane-agent can also get &lt;code>external&lt;/code> metrics by querying against prometheus servers. A new &lt;code>prometheus&lt;/code> quality probe
will be added to CRDs &lt;code>PodQOSEnsurancePolicy&lt;/code> and &lt;code>NodeQOSEnsurancePolicy&lt;/code> as shown in above 2 example yamls.&lt;/p>
&lt;p>In &lt;a href="#PodQOSEnsurancePolicy">PodQOSEnsurancePolicy&lt;/a>, &lt;code>.spec.nodeQualityProbe.prometheus.metrics.query&lt;/code> is a promQL, which
may includes some node variables (prefixed with &lt;code>$&lt;/code>). In this case, crane-agent will use its node name
to replace the variable &lt;code>$nodeName&lt;/code>.&lt;/p>
&lt;p>In &lt;a href="#PodQOSEnsurancePolicy">PodQOSEnsurancePolicy&lt;/a>, &lt;code>.spec.qualityProbe.prometheus.metrics.query&lt;/code> is a promQL, which
may includes some pod related variables (&lt;code>$nodeName&lt;/code>, &lt;code>$podName&lt;/code> in this example). Crane-agent will firstly
get all pods that match the &lt;code>.spec.selector.matchLabels&lt;/code> on its node. Say two pods are selected, and
their names are &lt;code>pod-1&lt;/code> and &lt;code>pod-2&lt;/code>, and the node name is &lt;code>node-1&lt;/code>. The replaced promQL will be&lt;/p>
&lt;pre tabindex="0">&lt;code>histogram_quantile(0.9, rate(http_request_duration_seconds_bucket{pod=~&amp;#34;pod-1|pod-2&amp;#34;, node=&amp;#34;node-1&amp;#34;}[1m]))
&lt;/code>&lt;/pre>&lt;p>And 2 query results are expected to get returned, like:&lt;/p>
&lt;pre tabindex="0">&lt;code>test_app_p90_latency{pod=&amp;#34;pod-1&amp;#34;, ...} 0.01
test_app_p90_latency{pod=&amp;#34;pod-2&amp;#34;, ...} 0.01
&lt;/code>&lt;/pre>&lt;p>Simply speaking, variables in promQL help crane-agent only query metrics of its own node and the pods that running on its own node.&lt;/p>
&lt;h4 id="embedded-metrics-tsdb">Embedded metrics TSDB&lt;/h4>
&lt;p>In order to decouple the components that collect metrics and those which consume the metrics, and to
make these components&amp;rsquo; logic simple, an embedded metrics TSDB will be imported into crane-agent.&lt;/p>
&lt;p>Prometheus-tsdb and vmstorage are two good candidates, both of which are easy to insert values and are
compatible with promQL query grammar.&lt;/p>
&lt;p>Both analyzer and executor fetch metrics from the TSDB without considering where the metrics come from.&lt;/p>
&lt;p>&lt;img src="/images/tsdb.png" alt="">&lt;/p>
&lt;h4 id="policy">Policy&lt;/h4>
&lt;p>The Open Policy Agent (OPA) is an open source, general-purpose policy engine that unifies policy enforcement.
Crane-agent will use it to evaluate if nodes or pods are abnormal.&lt;/p>
&lt;p>The criteria for detecting abnormality is not pre-defined or hardcoded, instead, it is customized by users
at runtime.&lt;/p>
&lt;p>A &lt;code>policy&lt;/code> filed will be added to &lt;code>ObjectiveEnsurance&lt;/code>, which is
a &lt;a href="https://www.openpolicyagent.org/docs/latest/policy-language/">rego&lt;/a> rule whose result is a boolean
element.&lt;/p>
&lt;p>crane-agent will feed both the latest built-in and external metrics as input into the OPA policy engine, and OPA
make decisions based on input and policies.&lt;/p>
&lt;p>&lt;img src="/images/opa.png" alt="">&lt;/p>
&lt;p>A sample input is as follows:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-json" data-lang="json">&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;crane&amp;#34;&lt;/span>: {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;cpu_total_usage&amp;#34;&lt;/span>: &lt;span style="color:#ae81ff">4680&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#960050;background-color:#1e0010">...&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">orhter&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">built-in&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">mertrcs&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> },
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;test_app_p90_latency&amp;#34;&lt;/span>: [
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;labels&amp;#34;&lt;/span>: {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;pod&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;pod-1&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;node&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;node-1&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> },
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;value&amp;#34;&lt;/span>: &lt;span style="color:#ae81ff">0.1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> },
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;labels&amp;#34;&lt;/span>: {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;pod&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;pod-2&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;node&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;node-1&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> },
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;value&amp;#34;&lt;/span>: &lt;span style="color:#ae81ff">0.09&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ],
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#960050;background-color:#1e0010">...&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>Docs: Recommendation Framework</title><link>/zh-cn/docs/proposals/20220706-recommendation-framework/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/zh-cn/docs/proposals/20220706-recommendation-framework/</guid><description>
&lt;p>Recommendation Framework provide a consistence progress to optimize variable kinds of resources in kubernetes. The progress should be Pluggable and support Multi-Cloud.&lt;/p>
&lt;h2 id="motivation">Motivation&lt;/h2>
&lt;p>Currently, we use &lt;code>Analytics&lt;/code> and &lt;code>Recommendation&lt;/code> to provide a recommendation service for workloads in cluster. Kubernetes&amp;rsquo; users use the recommendation to optimize the resource configuration and reduce their cost.
But the recommendations have some limitations now:&lt;/p>
&lt;ol>
&lt;li>Multiple Analytics can select some same resources, it&amp;rsquo;s confused and unnecessary to have two recommendation for the same resource.&lt;/li>
&lt;li>We need to support more kinds of resources, for example, scan for idle load balancers.&lt;/li>
&lt;li>We need to make the progress Pluggable to support different user in difference clouds.&lt;/li>
&lt;/ol>
&lt;h3 id="goals">Goals&lt;/h3>
&lt;ul>
&lt;li>Global analytics rules&lt;/li>
&lt;li>Easy to know the recommendation for my resource&lt;/li>
&lt;li>Consistence progress for all resource recommendation&lt;/li>
&lt;li>Plugin mechanism to support Multi-Cloud&lt;/li>
&lt;/ul>
&lt;h3 id="non-goals">Non-Goals&lt;/h3>
&lt;ul>
&lt;li>Cloud Resources that not included in kubernetes&lt;/li>
&lt;/ul>
&lt;h2 id="proposal">Proposal&lt;/h2>
&lt;h3 id="user-stories">User Stories&lt;/h3>
&lt;h4 id="story-1">Story 1&lt;/h4>
&lt;p>As a Serverless customer, I want to know the suitable requests and limits for my deployments, the result should be fit the existing pod model(e.g. 2c4g, 1c1g) in my cloud production.&lt;/p>
&lt;h4 id="story-2">Story 2&lt;/h4>
&lt;p>As an Aliyun ACK customer, I want to know whether there is a waste of LoadBalances in my cluster and delete them if exists.&lt;/p>
&lt;h4 id="story-3">Story 3&lt;/h4>
&lt;p>As a container platform user, I want to integrate optimize recommendation to my platform and optimize my cluster within my CICD pipeline.&lt;/p>
&lt;h3 id="api-definition">Api Definition&lt;/h3>
&lt;p>RecommendationRule defines which resources are required to recommend and what is the runInterval.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// RecommendationRuleSpec defines resources and runInterval to recommend
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">RecommendationRuleSpec&lt;/span> &lt;span style="color:#66d9ef">struct&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// ResourceSelector indicates how to select resources(e.g. a set of Deployments) for an Recommendation.
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">// +required
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">// +kubebuilder:validation:Required
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">ResourceSelectors&lt;/span> []&lt;span style="color:#a6e22e">ResourceSelector&lt;/span> &lt;span style="color:#e6db74">`json:&amp;#34;resourceSelectors&amp;#34;`&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// RunInterval between two recommendation
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">RunInterval&lt;/span> &lt;span style="color:#a6e22e">time&lt;/span>.&lt;span style="color:#a6e22e">Duration&lt;/span> &lt;span style="color:#e6db74">`json:&amp;#34;runInterval,omitempty&amp;#34;`&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// ResourceSelector describes how the resources will be selected.
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">ResourceSelector&lt;/span> &lt;span style="color:#66d9ef">struct&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// Kind of the resource, e.g. Deployment
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">Kind&lt;/span> &lt;span style="color:#66d9ef">string&lt;/span> &lt;span style="color:#e6db74">`json:&amp;#34;kind&amp;#34;`&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// API version of the resource, e.g. &amp;#34;apps/v1&amp;#34;
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">// +optional
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">APIVersion&lt;/span> &lt;span style="color:#66d9ef">string&lt;/span> &lt;span style="color:#e6db74">`json:&amp;#34;apiVersion,omitempty&amp;#34;`&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// Name of the resource.
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">// +optional
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">Name&lt;/span> &lt;span style="color:#66d9ef">string&lt;/span> &lt;span style="color:#e6db74">`json:&amp;#34;name,omitempty&amp;#34;`&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// +optional
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">LabelSelector&lt;/span> &lt;span style="color:#a6e22e">metav1&lt;/span>.&lt;span style="color:#a6e22e">LabelSelector&lt;/span> &lt;span style="color:#e6db74">`json:&amp;#34;labelSelector,omitempty&amp;#34;`&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">namespace&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">?&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Recommendation is a content holder for recommendation result. We hope that the recommendation data can be applied directly to kubernetes cluster(Recommendation as a code) and Different type recommendation have different recommendation yaml, so the content is stored in recommendation as &lt;code>Data&lt;/code>.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">Recommendation&lt;/span> &lt;span style="color:#66d9ef">struct&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">metav1&lt;/span>.&lt;span style="color:#a6e22e">TypeMeta&lt;/span> &lt;span style="color:#e6db74">`json:&amp;#34;,inline&amp;#34;`&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">metav1&lt;/span>.&lt;span style="color:#a6e22e">ObjectMeta&lt;/span> &lt;span style="color:#e6db74">`json:&amp;#34;metadata,omitempty&amp;#34;`&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// +kubebuilder:pruning:PreserveUnknownFields
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">Data&lt;/span> &lt;span style="color:#a6e22e">runtime&lt;/span>.&lt;span style="color:#a6e22e">RawExtension&lt;/span> &lt;span style="color:#e6db74">`json:&amp;#34;data&amp;#34;`&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="recommendation-configuration">Recommendation Configuration&lt;/h3>
&lt;p>Recommendation Configuration is centralized configuration that contains every rule for universal resource optimization. It not only includes RecommendationRules that use defines but also contains RecommendationPlugins.&lt;/p>
&lt;h3 id="phases-for-a-recommender">Phases for a recommender&lt;/h3>
&lt;p>&lt;img src="/images/crane_recommendation_framework.jpg" alt="">&lt;/p>
&lt;h3 id="phases">Phases&lt;/h3>
&lt;p>We divide the whole recommendation process into four actions, Fliter, Prepare, Recommend, Observe. The input of the whole system is the kubernetes resource you want to analyze, and the output is the best recommendation for the resource.Below we describe in detail the capabilities and input and output of each part of Recommendation Framework.&lt;/p>
&lt;h4 id="fliter">Fliter&lt;/h4>
&lt;p>The input of Fliter is an analysis recommendation task queue, and the queue stores the Recommendation CR submitted by the user.In default PreFliter,we will do nothing for the queue, this queue will be a FIFO queue.If you want to follow certain rules for the queue, you can implement it yourself PreFliter via extension point or override this func.In the default fliter stage, we will first filter the non-recommended resources according to the user-defined analyzable resource type. For example, the analyzable kubernetes resource I defined is deployment,ingress,node. If you submit a recommendation cr for statefulset, it will be abort in this phase.Then, we will check whether the resource you want exists, if not, we will abort.If you wish to use different filtering logic, you can implement your own logic through the fliter extension point or override it.&lt;/p>
&lt;h4 id="prepare">Prepare&lt;/h4>
&lt;p>Prepare is the data preparation stage, and will pull the indicator sequence within the specified time according to your recommended tasks.In PrePrepare,by default we will check the connectivity of the metrics system. And we need generate the specified metrics information for metrics server system like prometheus or metrics server. In Prepare,we will get the indicator sequence information.In PostPrepare, we will implement a data processing module.Some data processing such as data correction for cold start application resource glitch, missing data padding, data aggregation,deduplication or noise reduction. The output of whole will be normalized to a specified data type.Of course you can also implement your own PrePrepare, Prepare, PostPrepare logic.&lt;/p>
&lt;h4 id="recommend">Recommend&lt;/h4>
&lt;p>The input of Recommend is a data sequence, and the output is the result of the recommendation type you specify. For example, if your recommendation type is resource, the output is the recommended size of the resource of the kubernetes workload you specified.In Recommend, we will apply crane&amp;rsquo;s algorithm library to your data sequence.And in PostRecommend,We will use some strategies to regularize the results of the algorithm. For example, if a margin needs to be added when recommending resources, it will be processed at this stage.You can implement your own Recommend logic via extension points or override it.&lt;/p>
&lt;h4 id="observe">Observe&lt;/h4>
&lt;p>Observe is to intuitively reflect the effectiveness of the recommendation results. For example, when making resource recommendations, users not only care about the recommended resource configuration, but also how much cost can be saved after modifying the resource configuration. In PreObserver, we will check the cloud api connectivity and establish link with cloud vendor&amp;rsquo;s billing system. And in Observe we will turn resource optimization into cost optimization.You can implement your own Observe logic via extension points or override it.&lt;/p></description></item><item><title>Docs: Pod Sorting And Precise Execution For Crane Agent</title><link>/zh-cn/docs/proposals/pod-sorting-and-precise-execution-for-crane-agent/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/zh-cn/docs/proposals/pod-sorting-and-precise-execution-for-crane-agent/</guid><description>
&lt;p>该proposal丰富了crane-agent的排序策略，完善了通用排序。并且实现了一套精准操作(压制/驱逐)的框架，在执行压制/驱逐等操作时，操作到用户指定的水位线即停止的精确操作逻辑，避免了对于低优pod的过度操作；&lt;/p>
&lt;p>具体来说：&lt;/p>
&lt;ul>
&lt;li>丰富了crane-agent的排序策略，完善了通用排序和cpu usage为主要参考的cpu维度排序；&lt;/li>
&lt;li>针对cpu usage，实现了执行压制/驱逐等操作时，操作到用户指定的水位线即停止的精确操作逻辑，避免了对于低优pod的过度操作；&lt;/li>
&lt;li>实现了一套精确操作(压制/驱逐)的框架，通过完善自定义指标的一些列属性和实现，即可在无需关心具体细节的情况下，同样具有同cpu usage一样的精确操作能力，具有一定的普适性和扩展性。&lt;/li>
&lt;/ul>
&lt;h2 id="table-of-contents">Table of Contents&lt;/h2>
&lt;!-- TOC -->
&lt;ul>
&lt;li>[Pod Sorting And Precise Execution For Crane Agent](#Pod Sorting And Precise Execution For Crane Agent)
&lt;ul>
&lt;li>&lt;a href="#table-of-contents">Table of Contents&lt;/a>&lt;/li>
&lt;li>&lt;a href="#motivation">Motivation&lt;/a>
&lt;ul>
&lt;li>&lt;a href="#goals">Goals&lt;/a>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;a href="#proposal">Proposal&lt;/a>
&lt;ul>
&lt;li>&lt;a href="#%E4%B8%B0%E5%AF%8Cpod%E7%9A%84%E6%8E%92%E5%BA%8F%E7%AD%96%E7%95%A5">丰富pod的排序策略&lt;/a>&lt;/li>
&lt;li>&lt;a href="#metric%E5%B1%9E%E6%80%A7%E7%9A%84%E5%AE%9A%E4%B9%89">metric属性的定义&lt;/a>&lt;/li>
&lt;li>&lt;a href="#%E5%A6%82%E4%BD%95%E6%A0%B9%E6%8D%AE%E6%B0%B4%E4%BD%8D%E7%BA%BF%E8%BF%9B%E8%A1%8C%E7%B2%BE%E5%87%86%E6%8E%A7%E5%88%B6">如何根据水位线进行精准控制&lt;/a>&lt;/li>
&lt;li>&lt;a href="#%E4%BB%A5%E6%B0%B4%E4%BD%8D%E7%BA%BF%E4%B8%BA%E5%9F%BA%E5%87%86%E8%BF%9B%E8%A1%8Cpod%E7%9A%84%E7%B2%BE%E7%A1%AE%E6%93%8D%E4%BD%9C">以水位线为基准进行pod的精确操作&lt;/a>
&lt;ul>
&lt;li>&lt;a href="#analyzer%E9%98%B6%E6%AE%B5">analyzer阶段&lt;/a>&lt;/li>
&lt;li>&lt;a href="#executor%E9%98%B6%E6%AE%B5">executor阶段&lt;/a>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;a href="#non-goalsfuture-work">Non-Goals/Future Work&lt;/a>&lt;/li>
&lt;li>&lt;a href="#user-stories">User Stories&lt;/a>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;!-- /TOC -->
&lt;h2 id="motivation">Motivation&lt;/h2>
&lt;p>当前在crane-agent中，当超过NodeQOS中指定的水位线后，执行evict，throttle等操作时先对低优先级的pod进行排序，当前排序的依据是pod的ProrityClass，然后在排序的pod进行throttle或者evict操作；&lt;/p>
&lt;p>目前存在的问题有：&lt;/p>
&lt;ol>
&lt;li>
&lt;p>排序只参考ProrityClass，无法满足基于其他特性的排序；同时也无法满足按照水位线精确操作对灵活排序的需求，无法满足尽快让节点达到指定的水位线的要求。例如我们希望尽快降低低优先级业务的cpu使用量时，应该选出cpu使用量较多的pod，这样能够更快地降低cpu用量，保障高优业务不受影响。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>在触发NodeQOS中指定的水位线后，会对于节点上的所有低于指定ProrityClass的pod进行操作；例如，当前节点上有10个pod低于指定ProrityClass，在触发水位线后，会对这10个pod都进行操作，但是实际上可能在操作完成对第一个pod的操作后就可以低于NodeQOS中的指标值了，对剩下的pod的操作，属于过度操作，是可以避免的。如果能以NodeQOS中的指标值作为水位线对pod进行精确的操作，操作到刚好低于水位线是更为合适的，就能避免对低优先级服务的过度影响。&lt;/p>
&lt;/li>
&lt;/ol>
&lt;h3 id="goals">Goals&lt;/h3>
&lt;ul>
&lt;li>丰富了crane-agent的排序策略，包括以pod cpu用量为主要参照的排序，以pod内存用量为主要参照的排序，基于运行时间的排序，基于扩展资源使用率的排序。&lt;/li>
&lt;li>实现一套包含排序和精确操作的框架，支持对不同的指标丰富排序规则，并且实现精确操作。&lt;/li>
&lt;li>实现针对cpu usage和memmory usage的精确操作，当整机负载超过NodeQOS中指定的水位线后，会先对低优先级的pod进行排序，然后按照顺序操作到刚好低于水位线为止。&lt;/li>
&lt;/ul>
&lt;h2 id="proposal">Proposal&lt;/h2>
&lt;h3 id="丰富pod的排序策略">丰富pod的排序策略&lt;/h3>
&lt;ul>
&lt;li>
&lt;p>该proposal实现了一些通用的排序方法（之后会更多地完善）：&lt;/p>
&lt;p>classAndPriority： 比较两个pod的QOSClass和class value，优先比较QOSClass，再比较class value；priority高的排在后面优先级更高&lt;/p>
&lt;p>runningTime：比较两个pod的运行时间，运行时间长的排在后面优先级更高&lt;/p>
&lt;p>如果仅需使用这两个排序策略，使用默认的排序方法即可：会首先比较pod的优先级，之后比较pod对应指标的用量，之后比较pod的运行时长，有一个维度可以比较出结果即为pod的排序结果&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">GeneralSorter&lt;/span>(&lt;span style="color:#a6e22e">pods&lt;/span> []&lt;span style="color:#a6e22e">podinfo&lt;/span>.&lt;span style="color:#a6e22e">PodContext&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">orderedBy&lt;/span>(&lt;span style="color:#a6e22e">classAndPriority&lt;/span>, &lt;span style="color:#a6e22e">runningTime&lt;/span>).&lt;span style="color:#a6e22e">Sort&lt;/span>(&lt;span style="color:#a6e22e">pods&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;li>
&lt;p>cpu usage 使用量的排序&lt;/p>
&lt;p>会依次比较两个pod的优先级，如果优先级相同的情况下，再比较cpu用量，如果cpu用量也相同的情况下继续比较ext cpu资源用量（这个是cpu属性较为特殊的一点）, 最后比较pod的运行时长，当某一个指标存在差异时即可返回比较结果&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">CpuUsageSorter&lt;/span>(&lt;span style="color:#a6e22e">pods&lt;/span> []&lt;span style="color:#a6e22e">podinfo&lt;/span>.&lt;span style="color:#a6e22e">PodContext&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">orderedBy&lt;/span>(&lt;span style="color:#a6e22e">classAndPriority&lt;/span>, &lt;span style="color:#a6e22e">cpuUsage&lt;/span>, &lt;span style="color:#a6e22e">extCpuUsage&lt;/span>, &lt;span style="color:#a6e22e">runningTime&lt;/span>).&lt;span style="color:#a6e22e">Sort&lt;/span>(&lt;span style="color:#a6e22e">pods&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;li>
&lt;p>ext cpu usage 使用量的排序&lt;/p>
&lt;p>会首先比较两个pod是否使用了扩展的cpu资源，在都使用了的情况下，比较 扩展cpu资源使用量/ 扩展cpu资源limit的比值&lt;/p>
&lt;/li>
&lt;li>
&lt;p>针对需要自定义的指标，可以通过实现如下的方法，并且随意搭配通用的排序方法即可方便地实现pod的灵活自定义排序，以&lt;metric>代表自定义metric指标，&lt;metric-sort-func>代表自定义的针对&lt;metric>的排序策略&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">func&lt;/span> &amp;lt;&lt;span style="color:#a6e22e">metric&lt;/span>&amp;gt;&lt;span style="color:#a6e22e">Sorter&lt;/span>(&lt;span style="color:#a6e22e">pods&lt;/span> []&lt;span style="color:#a6e22e">podinfo&lt;/span>.&lt;span style="color:#a6e22e">PodContext&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">orderedBy&lt;/span>(&lt;span style="color:#a6e22e">classAndPriority&lt;/span>, &amp;lt;&lt;span style="color:#a6e22e">metric&lt;/span>&lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#a6e22e">sort&lt;/span>&lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#66d9ef">func&lt;/span>&amp;gt;, &lt;span style="color:#a6e22e">runningTime&lt;/span>).&lt;span style="color:#a6e22e">Sort&lt;/span>(&lt;span style="color:#a6e22e">pods&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>其中&lt;metric-sort-func>只需要实现如下的排序方法即可&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">func&lt;/span> (&lt;span style="color:#a6e22e">p1&lt;/span>, &lt;span style="color:#a6e22e">p2&lt;/span> &lt;span style="color:#a6e22e">podinfo&lt;/span>.&lt;span style="color:#a6e22e">PodContext&lt;/span>) &lt;span style="color:#66d9ef">int32&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;/ul>
&lt;h3 id="metric属性的定义">metric属性的定义&lt;/h3>
&lt;p>为了更好的基于NodeQOS配置的metric进行排序和精准控制，对metric引入属性的概念。&lt;/p>
&lt;p>metric的属性包含如下几个：&lt;/p>
&lt;ol>
&lt;li>Name 表明了metric的名称，需要同collector模块中收集到的指标名称一致&lt;/li>
&lt;li>ActionPriority 表示指标的优先级，0为最低，10为最高&lt;/li>
&lt;li>SortAble 表明该指标是否可以排序&lt;/li>
&lt;li>SortFunc 对应的排序方法，排序方法可以排列组合一些通用方法，再结合指标自身的排序，将在下文详细介绍&lt;/li>
&lt;li>ThrottleAble 表明针对该指标，是否可以对pod进行压制，例如针对cpu使用量这个metric，就有相对应的压制手段，但是对于memory使用量这种指标，就只能进行pod的驱逐，无法进行有效的压制&lt;/li>
&lt;li>ThrottleQuantified 表明压制（restore）一个pod后，能否准确计算出经过压制后释放出的对应metric的资源量，我们将可以准确量化的指标称为可Quantified，否则为不可Quantified；
比如cpu用量，可以通过限制cgroup用量进行压制，同时可以通过当前运行值和压制后的值计算压制后释放的cpu使用量；而比如memory usage就不属于压制可量化metric，因为memory没有对应的throttle实现，也就无法准确衡量压制一个pod后释放出来的memory资源具体用量；&lt;/li>
&lt;li>ThrottleFunc，执行Throttle动作的具体方法，如果不可Throttle，返回的released为空&lt;/li>
&lt;li>RestoreFunc，被Throttle后，执行恢复动作的具体方法，如果不可Restore，返回的released为空&lt;/li>
&lt;li>EvictAble，EvictQuantified，EvictFunc 对evict动作的相关定义，具体内容和Throttle动作类似&lt;/li>
&lt;/ol>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">metric&lt;/span> &lt;span style="color:#66d9ef">struct&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">Name&lt;/span> &lt;span style="color:#a6e22e">WaterLineMetric&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">ActionPriority&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">SortAble&lt;/span> &lt;span style="color:#66d9ef">bool&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">SortFunc&lt;/span> &lt;span style="color:#66d9ef">func&lt;/span>(&lt;span style="color:#a6e22e">pods&lt;/span> []&lt;span style="color:#a6e22e">podinfo&lt;/span>.&lt;span style="color:#a6e22e">PodContext&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">ThrottleAble&lt;/span> &lt;span style="color:#66d9ef">bool&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">ThrottleQuantified&lt;/span> &lt;span style="color:#66d9ef">bool&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">ThrottleFunc&lt;/span> &lt;span style="color:#66d9ef">func&lt;/span>(&lt;span style="color:#a6e22e">ctx&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">ExecuteContext&lt;/span>, &lt;span style="color:#a6e22e">index&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span>, &lt;span style="color:#a6e22e">ThrottleDownPods&lt;/span> &lt;span style="color:#a6e22e">ThrottlePods&lt;/span>, &lt;span style="color:#a6e22e">totalReleasedResource&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">ReleaseResource&lt;/span>) (&lt;span style="color:#a6e22e">errPodKeys&lt;/span> []&lt;span style="color:#66d9ef">string&lt;/span>, &lt;span style="color:#a6e22e">released&lt;/span> &lt;span style="color:#a6e22e">ReleaseResource&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">RestoreFunc&lt;/span> &lt;span style="color:#66d9ef">func&lt;/span>(&lt;span style="color:#a6e22e">ctx&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">ExecuteContext&lt;/span>, &lt;span style="color:#a6e22e">index&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span>, &lt;span style="color:#a6e22e">ThrottleUpPods&lt;/span> &lt;span style="color:#a6e22e">ThrottlePods&lt;/span>, &lt;span style="color:#a6e22e">totalReleasedResource&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">ReleaseResource&lt;/span>) (&lt;span style="color:#a6e22e">errPodKeys&lt;/span> []&lt;span style="color:#66d9ef">string&lt;/span>, &lt;span style="color:#a6e22e">released&lt;/span> &lt;span style="color:#a6e22e">ReleaseResource&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">EvictAble&lt;/span> &lt;span style="color:#66d9ef">bool&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">EvictQuantified&lt;/span> &lt;span style="color:#66d9ef">bool&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">EvictFunc&lt;/span> &lt;span style="color:#66d9ef">func&lt;/span>(&lt;span style="color:#a6e22e">wg&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">sync&lt;/span>.&lt;span style="color:#a6e22e">WaitGroup&lt;/span>, &lt;span style="color:#a6e22e">ctx&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">ExecuteContext&lt;/span>, &lt;span style="color:#a6e22e">index&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span>, &lt;span style="color:#a6e22e">totalReleasedResource&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">ReleaseResource&lt;/span>, &lt;span style="color:#a6e22e">EvictPods&lt;/span> &lt;span style="color:#a6e22e">EvictPods&lt;/span>) (&lt;span style="color:#a6e22e">errPodKeys&lt;/span> []&lt;span style="color:#66d9ef">string&lt;/span>, &lt;span style="color:#a6e22e">released&lt;/span> &lt;span style="color:#a6e22e">ReleaseResource&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>用户可以自行定义自己的metric，在构造完成后，通过registerMetricMap()进行注册即可&lt;/p>
&lt;h3 id="如何根据水位线进行精准控制">如何根据水位线进行精准控制&lt;/h3>
&lt;ul>
&lt;li>
&lt;p>根据多个NodeQOS及其中的objectiveEnsurances构建多条水位线:&lt;/p>
&lt;ol>
&lt;li>
&lt;p>按照objectiveEnsurances对应的action进行分类，目前crane-agent有3个针对节点QOS进行保障的操作，分别是Evict，ThtottleDown（当前用量高于objectiveEnsurances中的值时对pod进行用量压制）和ThrottleUp（当前用量低于objectiveEnsurances中的值时对pod的用量进行放宽恢复），因此会有三个水位线集合，分别是
ThrottleDownWaterLine，ThrottleUpWaterLine和EvictWaterLine&lt;/p>
&lt;/li>
&lt;li>
&lt;p>再对同一操作种类中的水位线按照其metric rule（图中以metric A，metric Z作为示意）进行分类，并记录每个objectiveEnsurances水位线的值，记为waterLine；&lt;/p>
&lt;p>ThrottleDownWaterLine，ThrottleUpWaterLine和EvictWaterLine的结构是这样的：
&lt;code>type WaterLines map[WaterLineMetric]*WaterLine&lt;/code>&lt;/p>
&lt;p>其中WaterLineMetric就是上面的metric的Name字段，value的WaterLine就是资源数值
&lt;code>type WaterLine resource.Quantity&lt;/code>&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p>最终形成一个类似下图的数据存储：&lt;br>
&lt;img src="/images/waterline-construct.png" alt="">&lt;/p>
&lt;/li>
&lt;li>
&lt;p>构造实时用量到水位线的差值：&lt;br>
结合当前节点的指标实时用量与WaterLines中该指标对应的水位线中最小值的差值构造如下的数据结构，代表到当前用量到水位线的差值&lt;br>
&lt;code>type GapToWaterLines map[WaterLineMetric]float64&lt;/code>&lt;/p>
&lt;p>其中key值为metric的Name字段，value为用量到水位线的差值；&lt;/p>
&lt;p>需要注意对于ThrottleUp，需要用水位线最小值-当前用量作为gap值，对于其他两者，使用当前用量-水位线最小值作为gap值，即始终保持gap值为正&lt;/p>
&lt;p>下面三个数据分别代表了需要执行evict，ThtottleDown和ThrottleUp操作的指标及其对应的到最低水位线的差值&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">EvictGapToWaterLines&lt;/span>[&lt;span style="color:#a6e22e">metrics&lt;/span>]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">ThrottoleDownGapToWaterLines&lt;/span>[&lt;span style="color:#a6e22e">metrics&lt;/span>]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">ThrottleUpGapWaterLine&lt;/span>[&lt;span style="color:#a6e22e">metrics&lt;/span>]
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;li>
&lt;p>以CpuUsage这个metric为例，构造节点cpu用量相关的waterline的流程和相关数据结构如下：&lt;br>
&lt;img src="/images/cpu-usage-water-line.png" alt="">&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h3 id="以水位线为基准进行pod的精确操作">以水位线为基准进行pod的精确操作&lt;/h3>
&lt;p>该proposal为了实现以水位线为基准进行pod的精确操作，将对analyzer部分和executor部分做一定的修改，大体流程是：&lt;/p>
&lt;p>在analyzer阶段构造针对不同操作（驱逐，压制等）和不同metric的水位线，将原先的排序逻辑删除，后移到需要进行正式操作的executor阶段，并且可能会需要进行多轮排序；&lt;/p>
&lt;p>在executor阶段，根据水位线中的涉及的指标进行其相应的排序，获取最新用量，构造GapToWaterLines，并进行精确操作&lt;/p>
&lt;h4 id="analyzer阶段">analyzer阶段&lt;/h4>
&lt;p>在该阶段进行NodeQOS到WaterLines的转换，并对相同actionName和metricrule的规则进行合并，具体内容上文已经介绍过了&lt;/p>
&lt;h4 id="executor阶段">executor阶段&lt;/h4>
&lt;p>压制过程：&lt;/p>
&lt;ol>
&lt;li>
&lt;p>首先分析ThrottoleDownGapToWaterLines中涉及的metrics，将这些metrics根据其Quantified属性区分为两部分，如果存在不可Quantified的metric，则通过GetHighestPriorityThrottleAbleMetric获取具有最高ActionPriority的一个throttleAble（具有throttleFunc）的metric对所选择的所有pod进行压制操作，因为但凡存在一个不可Quantified的metric，就无法进行精确的操作&lt;/p>
&lt;/li>
&lt;li>
&lt;p>通过getStateFunc()获取当前节点和workload的最新用量，依据ThrottoleDownGapToWaterLines和实时用量构造GapToWaterLine（需要注意的是，在构造GapToWaterLine时，会以注册过的metric进行遍历，所以最终构造出来的GapToWaterLine中的metrics，会是ThrottoleDownGapToWaterLines
中注册过的metric，避免了在NodeQOS中配置错误不存在或未注册metric的情况）&lt;/p>
&lt;/li>
&lt;li>
&lt;p>如果GapToWaterLine中有metric的实时用量无法获取（HasUsageMissedMetric），则通过GetHighestPriorityThrottleAbleMetric获取具有最高ActionPriority的一个throttleAble（具有throttleFunc）的metric对所选择的所有pod进行压制操作，因为如果存在metric实时用量无法获取，就无法获知和水位线的gap，也就无法进行精确的操作&lt;/p>
&lt;/li>
&lt;li>
&lt;p>如果不存在3中的情况，则遍历ThrottoleDownGapToWaterLines中可以量化的metric：如果metric具有排序方法则直接使用其SortFunc对pod进行排序，如果没有就使用GeneralSorter进行排序，之后使用其对应的ThrottleFunc对pod进行压制，并计算释放出来的对应metric的资源量，直到ThrottoleDownGapToWaterLines中该metric对应的gap已不存在&lt;/p>
&lt;/li>
&lt;/ol>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">//将所有触发水位线的metrics根据其Quantified属性区分为两部分
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#a6e22e">metricsQuantified&lt;/span>, &lt;span style="color:#a6e22e">MetricsNotQuantified&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">ThrottleDownWaterLine&lt;/span>.&lt;span style="color:#a6e22e">DivideMetricsByQuantified&lt;/span>()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 如果存在不可Quantified的metric，获取具有最高ActionPriority的一个throttleAble的metric对所选择的所有pod进行操作
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">if&lt;/span> len(&lt;span style="color:#a6e22e">MetricsNotThrottleQuantified&lt;/span>) &lt;span style="color:#f92672">!=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">highestPrioriyMetric&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">GetHighestPriorityThrottleAbleMetric&lt;/span>()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#a6e22e">highestPrioriyMetric&lt;/span> &lt;span style="color:#f92672">!=&lt;/span> &lt;span style="color:#e6db74">&amp;#34;&amp;#34;&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">t&lt;/span>.&lt;span style="color:#a6e22e">throttlePods&lt;/span>(&lt;span style="color:#a6e22e">ctx&lt;/span>, &lt;span style="color:#f92672">&amp;amp;&lt;/span>&lt;span style="color:#a6e22e">totalReleased&lt;/span>, &lt;span style="color:#a6e22e">highestPrioriyMetric&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>} &lt;span style="color:#66d9ef">else&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">//获取节点和workload的最新用量，构造和水位线差距
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">ThrottoleDownGapToWaterLines&lt;/span> = &lt;span style="color:#a6e22e">buildGapToWaterLine&lt;/span>(&lt;span style="color:#a6e22e">ctx&lt;/span>.&lt;span style="color:#a6e22e">getStateFunc&lt;/span>())
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">//如果触发水位线中存在metric的实时用量无法获取，则获取具有最高ActionPriority的一个throttleAble的metric对所选择的所有pod进行压制操作
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#a6e22e">ThrottoleDownGapToWaterLines&lt;/span>.&lt;span style="color:#a6e22e">HasUsageMissedMetric&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">highestPrioriyMetric&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">ThrottleDownWaterLine&lt;/span>.&lt;span style="color:#a6e22e">GetHighestPriorityThrottleAbleMetric&lt;/span>()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#a6e22e">highestPrioriyMetric&lt;/span> &lt;span style="color:#f92672">!=&lt;/span> &lt;span style="color:#e6db74">&amp;#34;&amp;#34;&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">throttlePods&lt;/span>(&lt;span style="color:#a6e22e">ctx&lt;/span>, &lt;span style="color:#f92672">&amp;amp;&lt;/span>&lt;span style="color:#a6e22e">totalReleased&lt;/span>, &lt;span style="color:#a6e22e">highestPrioriyMetric&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#66d9ef">else&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">var&lt;/span> &lt;span style="color:#a6e22e">released&lt;/span> &lt;span style="color:#a6e22e">ReleaseResource&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">//遍历触发水位线的metric中可以量化的metric：如果metric具有排序方法则直接使用其SortFunc对pod进行排序，否则使用GeneralSorter排序；
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">//之后使用其对应的操作方法对pod执行操作，并计算释放出来的对应metric的资源量，直到对应metric到水位线的差距已不存在
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">for&lt;/span> &lt;span style="color:#a6e22e">_&lt;/span>, &lt;span style="color:#a6e22e">m&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#66d9ef">range&lt;/span> &lt;span style="color:#a6e22e">metricsQuantified&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#a6e22e">m&lt;/span>.&lt;span style="color:#a6e22e">SortAble&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">m&lt;/span>.&lt;span style="color:#a6e22e">SortFunc&lt;/span>(&lt;span style="color:#a6e22e">ThrottleDownPods&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#66d9ef">else&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">GeneralSorter&lt;/span>(&lt;span style="color:#a6e22e">ThrottleDownPods&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> !&lt;span style="color:#a6e22e">ThrottoleDownGapToWaterLines&lt;/span>.&lt;span style="color:#a6e22e">TargetGapsRemoved&lt;/span>(&lt;span style="color:#a6e22e">m&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> &lt;span style="color:#a6e22e">index&lt;/span>, &lt;span style="color:#a6e22e">_&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#66d9ef">range&lt;/span> &lt;span style="color:#a6e22e">ThrottleDownPods&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">released&lt;/span> = &lt;span style="color:#a6e22e">m&lt;/span>.&lt;span style="color:#a6e22e">ThrottleFunc&lt;/span>(&lt;span style="color:#a6e22e">ctx&lt;/span>, &lt;span style="color:#a6e22e">index&lt;/span>, &lt;span style="color:#a6e22e">ThrottleDownPods&lt;/span>, &lt;span style="color:#f92672">&amp;amp;&lt;/span>&lt;span style="color:#a6e22e">totalReleased&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">ThrottoleDownGapToWaterLines&lt;/span>[&lt;span style="color:#a6e22e">m&lt;/span>] &lt;span style="color:#f92672">-=&lt;/span> &lt;span style="color:#a6e22e">released&lt;/span>[&lt;span style="color:#a6e22e">m&lt;/span>]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>驱逐过程：&lt;/p>
&lt;p>驱逐和压制的流程是一样的，除了在对pod进行操作的时候需要额外判断一下pod是否已经被驱逐了；取出一个没有执行过的pod，执行驱逐操作，并计算释放出的各metric资源量，同时在对应水位线中减去释放的值，直到满足当前metric水位线要求&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">metricsEvictQuantified&lt;/span>, &lt;span style="color:#a6e22e">MetricsNotEvcitQuantified&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">EvictWaterLine&lt;/span>.&lt;span style="color:#a6e22e">DivideMetricsByEvictQuantified&lt;/span>()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">if&lt;/span> len(&lt;span style="color:#a6e22e">MetricsNotEvcitQuantified&lt;/span>) &lt;span style="color:#f92672">!=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">highestPrioriyMetric&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">e&lt;/span>.&lt;span style="color:#a6e22e">EvictWaterLine&lt;/span>.&lt;span style="color:#a6e22e">GetHighestPriorityEvictAbleMetric&lt;/span>()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#a6e22e">highestPrioriyMetric&lt;/span> &lt;span style="color:#f92672">!=&lt;/span> &lt;span style="color:#e6db74">&amp;#34;&amp;#34;&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">e&lt;/span>.&lt;span style="color:#a6e22e">evictPods&lt;/span>(&lt;span style="color:#a6e22e">ctx&lt;/span>, &lt;span style="color:#f92672">&amp;amp;&lt;/span>&lt;span style="color:#a6e22e">totalReleased&lt;/span>, &lt;span style="color:#a6e22e">highestPrioriyMetric&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>} &lt;span style="color:#66d9ef">else&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">EvictGapToWaterLines&lt;/span> = &lt;span style="color:#a6e22e">buildGapToWaterLine&lt;/span>(&lt;span style="color:#a6e22e">ctx&lt;/span>.&lt;span style="color:#a6e22e">getStateFunc&lt;/span>(), &lt;span style="color:#a6e22e">ThrottleExecutor&lt;/span>{}, &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">e&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#a6e22e">EvictGapToWaterLines&lt;/span>.&lt;span style="color:#a6e22e">HasUsageMissedMetric&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">highestPrioriyMetric&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">EvictWaterLine&lt;/span>.&lt;span style="color:#a6e22e">GetHighestPriorityEvictAbleMetric&lt;/span>()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#a6e22e">highestPrioriyMetric&lt;/span> &lt;span style="color:#f92672">!=&lt;/span> &lt;span style="color:#e6db74">&amp;#34;&amp;#34;&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">e&lt;/span>.&lt;span style="color:#a6e22e">evictPods&lt;/span>(&lt;span style="color:#a6e22e">ctx&lt;/span>, &lt;span style="color:#f92672">&amp;amp;&lt;/span>&lt;span style="color:#a6e22e">totalReleased&lt;/span>, &lt;span style="color:#a6e22e">highestPrioriyMetric&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#66d9ef">else&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">wg&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">sync&lt;/span>.&lt;span style="color:#a6e22e">WaitGroup&lt;/span>{}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">var&lt;/span> &lt;span style="color:#a6e22e">released&lt;/span> &lt;span style="color:#a6e22e">ReleaseResource&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> &lt;span style="color:#a6e22e">_&lt;/span>, &lt;span style="color:#a6e22e">m&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#66d9ef">range&lt;/span> &lt;span style="color:#a6e22e">metricsEvictQuantified&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#a6e22e">MetricMap&lt;/span>[&lt;span style="color:#a6e22e">m&lt;/span>].&lt;span style="color:#a6e22e">SortAble&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">MetricMap&lt;/span>[&lt;span style="color:#a6e22e">m&lt;/span>].&lt;span style="color:#a6e22e">SortFunc&lt;/span>(&lt;span style="color:#a6e22e">e&lt;/span>.&lt;span style="color:#a6e22e">EvictPods&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#66d9ef">else&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">execsort&lt;/span>.&lt;span style="color:#a6e22e">GeneralSorter&lt;/span>(&lt;span style="color:#a6e22e">e&lt;/span>.&lt;span style="color:#a6e22e">EvictPods&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> !&lt;span style="color:#a6e22e">EvictGapToWaterLines&lt;/span>.&lt;span style="color:#a6e22e">TargetGapsRemoved&lt;/span>(&lt;span style="color:#a6e22e">m&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#a6e22e">podinfo&lt;/span>.&lt;span style="color:#a6e22e">HasNoExecutedPod&lt;/span>(&lt;span style="color:#a6e22e">e&lt;/span>.&lt;span style="color:#a6e22e">EvictPods&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">index&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">podinfo&lt;/span>.&lt;span style="color:#a6e22e">GetFirstNoExecutedPod&lt;/span>(&lt;span style="color:#a6e22e">e&lt;/span>.&lt;span style="color:#a6e22e">EvictPods&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">released&lt;/span> = &lt;span style="color:#a6e22e">MetricMap&lt;/span>[&lt;span style="color:#a6e22e">m&lt;/span>].&lt;span style="color:#a6e22e">EvictFunc&lt;/span>(&lt;span style="color:#f92672">&amp;amp;&lt;/span>&lt;span style="color:#a6e22e">wg&lt;/span>, &lt;span style="color:#a6e22e">ctx&lt;/span>, &lt;span style="color:#a6e22e">index&lt;/span>, &lt;span style="color:#f92672">&amp;amp;&lt;/span>&lt;span style="color:#a6e22e">totalReleased&lt;/span>, &lt;span style="color:#a6e22e">e&lt;/span>.&lt;span style="color:#a6e22e">EvictPods&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">e&lt;/span>.&lt;span style="color:#a6e22e">EvictPods&lt;/span>[&lt;span style="color:#a6e22e">index&lt;/span>].&lt;span style="color:#a6e22e">HasBeenActioned&lt;/span> = &lt;span style="color:#66d9ef">true&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">ctx&lt;/span>.&lt;span style="color:#a6e22e">EvictGapToWaterLines&lt;/span>[&lt;span style="color:#a6e22e">m&lt;/span>] &lt;span style="color:#f92672">-=&lt;/span> &lt;span style="color:#a6e22e">released&lt;/span>[&lt;span style="color:#a6e22e">m&lt;/span>]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">wg&lt;/span>.&lt;span style="color:#a6e22e">Wait&lt;/span>()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="non-goalsfuture-work">Non-Goals/Future Work&lt;/h3>
&lt;ul>
&lt;li>当前只支持cpu usage的精确操作，但是框架可以复用，后续可以基于精准控制的框架，实现更多维度指标的精准控制。&lt;/li>
&lt;li>在做精准控制时，目前只考虑metric本身释放量，未考虑不同metric之间的相互影响。比如压制cpu usage时，memory usage也会受到影响。如果指标非常多，不同指标之间的关系会非常复杂，所以暂时不考虑不同metric直接的相互影响。&lt;/li>
&lt;/ul>
&lt;h3 id="user-stories">User Stories&lt;/h3>
&lt;ul>
&lt;li>用户可以使用crane-agent进行更好的QOS保障。支持更快速的降低节点负载，以保障高优先级业务不受影响。同时对低优先级业务的压制/驱逐动作，进行精确控制，避免过度操作。&lt;/li>
&lt;li>用户可以借助实现的精准操作(压制/驱逐)的框架，在无需关心细节的情况下，通过实现自定义metric相关的属性和方法，即可方便地实现以自定义metric为核心的具有精确操作和排序能力的QOS功能。&lt;/li>
&lt;/ul></description></item></channel></rss>