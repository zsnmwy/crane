<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Crane – 教程</title><link>/zh-cn/docs/tutorials/</link><description>Recent content in 教程 on Crane</description><generator>Hugo -- gohugo.io</generator><atom:link href="/zh-cn/docs/tutorials/index.xml" rel="self" type="application/rss+xml"/><item><title>Docs: QOS增强与混布</title><link>/zh-cn/docs/tutorials/colocation-with-enhanced-qos/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/zh-cn/docs/tutorials/colocation-with-enhanced-qos/</guid><description/></item><item><title>Docs: 智能推荐</title><link>/zh-cn/docs/tutorials/recommendation/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/zh-cn/docs/tutorials/recommendation/</guid><description/></item><item><title>Docs: 动态调度器：一个基于负载感知的调度插件</title><link>/zh-cn/docs/tutorials/dynamic-scheduler-plugin/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/zh-cn/docs/tutorials/dynamic-scheduler-plugin/</guid><description>
&lt;p>kubernetes 的原生调度器只能通过资源请求来调度 pod，这很容易造成一系列负载不均的问题：&lt;/p>
&lt;ul>
&lt;li>对于某些节点，实际负载与资源请求相差不大，这会导致很大概率出现稳定性问题。&lt;/li>
&lt;li>对于其他节点来说，实际负载远小于资源请求，这将导致资源的巨大浪费。&lt;/li>
&lt;/ul>
&lt;p>为了解决这些问题，动态调度器根据实际的节点利用率构建了一个简单但高效的模型，并过滤掉那些负载高的节点来平衡集群。&lt;/p>
&lt;h2 id="设计细节">设计细节&lt;/h2>
&lt;h3 id="架构">架构&lt;/h3>
&lt;p>&lt;img src="/images/dynamic-scheduler-plugin.png" alt="">&lt;/p>
&lt;p>如上图，动态调度器依赖于&lt;code>Prometheus&lt;/code>和&lt;code>Node-exporter&lt;/code>收集和汇总指标数据，它由两个组件组成：&lt;/p>
&lt;p>!!! note &amp;ldquo;Note&amp;rdquo;
&lt;code>Node-annotator&lt;/code> 目前是 &lt;code>Crane-scheduler-controller&lt;/code>的一个模块.&lt;/p>
&lt;ul>
&lt;li>&lt;code>Node-annotator&lt;/code>定期从 Prometheus 拉取数据，并以注释的形式在节点上用时间戳标记它们。&lt;/li>
&lt;li>&lt;code>Dynamic plugin&lt;/code>直接从节点的注释中读取负载数据，过滤并基于简单的算法对候选节点进行评分。&lt;/li>
&lt;/ul>
&lt;h3 id="调度策略">调度策略&lt;/h3>
&lt;p>动态调度器提供了一个默认值&lt;a href="../deploy/manifests/policy.yaml">调度策略&lt;/a>并支持用户自定义策略。默认策略依赖于以下指标：&lt;/p>
&lt;ul>
&lt;li>&lt;code>cpu_usage_avg_5m&lt;/code>&lt;/li>
&lt;li>&lt;code>cpu_usage_max_avg_1h&lt;/code>&lt;/li>
&lt;li>&lt;code>cpu_usage_max_avg_1d&lt;/code>&lt;/li>
&lt;li>&lt;code>mem_usage_avg_5m&lt;/code>&lt;/li>
&lt;li>&lt;code>mem_usage_max_avg_1h&lt;/code>&lt;/li>
&lt;li>&lt;code>mem_usage_max_avg_1d&lt;/code>&lt;/li>
&lt;/ul>
&lt;p>在调度的&lt;code>Filter&lt;/code>阶段，如果该节点的实际使用率大于上述任一指标的阈值，则该节点将被过滤。而在&lt;code>Score&lt;/code>阶段，最终得分是这些指标值的加权和。&lt;/p>
&lt;h3 id="hot-value">Hot Value&lt;/h3>
&lt;p>在生产集群中，可能会频繁出现调度热点，因为创建 Pod 后节点的负载不能立即增加。因此，我们定义了一个额外的指标，名为&lt;code>Hot Value&lt;/code>，表示节点最近几次的调度频率。并且节点的最终优先级是最终得分减去&lt;code>Hot Value&lt;/code>。&lt;/p></description></item><item><title>Docs: 精细化调度器：一个感知节点资源拓扑的调度插件</title><link>/zh-cn/docs/tutorials/node-resource-tpolology-scheduler-plugins/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/zh-cn/docs/tutorials/node-resource-tpolology-scheduler-plugins/</guid><description>
&lt;h2 id="总览">总览&lt;/h2>
&lt;p>现代多核服务器大多采用非统一内存访问架构（英语：Non-uniform memory access，简称NUMA）来提高硬件的可伸缩性。NUMA是一种为多处理器的电脑设计的内存架构，内存访问时间取决于内存相对于处理器的位置。在NUMA下，处理器访问它自己的本地内存的速度比非本地内存（内存位于另一个处理器，或者是处理器之间共享的内存）快一些。&lt;/p>
&lt;p>在 Kubernetes 中，&lt;strong>调度&lt;/strong>是指将 &lt;a href="https://kubernetes.io/zh-cn/docs/concepts/workloads/pods/">Pod&lt;/a> 放置到合适的&lt;a href="https://kubernetes.io/zh-cn/docs/concepts/architecture/nodes/">节点&lt;/a>上，一个节点会运行多个Pod。因此，调度器的调度粒度为节点级别，并不感知和考虑节点硬件拓扑的存在。在某些延迟敏感的场景下，可能希望Kubernetes为Pod分配拓扑最优的节点和硬件，以提升硬件利用率和程序性能。&lt;/p>
&lt;p>同时，在某些复杂场景下，部分的Pod属于CPU密集型工作负载，Pod之间会争抢节点的CPU资源。当争抢剧烈的时候，Pod会在不同的CPU Core之间进行频繁的切换，更糟糕的是在NUMA Node之间的切换。这种大量的上下文切换，会影响程序运行的性能。&lt;/p>
&lt;p>Kubernetes中虽然有Topology Manager来管理节点资源的拓扑对齐，但是没有与调度器联动，导致调度结果和设备资源分配结果可能不一致。&lt;/p>
&lt;p>为了解决这一问题，资源拓扑感知调度给予了精细调度的能力，将调度的粒度扩展到设备级别。&lt;/p>
&lt;h2 id="设计细节">设计细节&lt;/h2>
&lt;h3 id="架构">架构&lt;/h3>
&lt;p>&lt;img src="/images/topology-awareness-architecture.png" alt="topology-awareness-architecture">&lt;/p>
&lt;p>Crane-Scheduler和Crane-Agent配合工作，完成拓扑感知调度与资源分配的工作。&lt;/p>
&lt;p>Crane-Agent从节点采集资源拓扑，包括NUMA、Socket、设备等信息，汇总到NodeResourceTopology这个自定义资源对象中。&lt;/p>
&lt;p>Crane-Scheduler在调度时会参考节点的NodeResourceTopology对象获取到节点详细的资源拓扑结构，在调度到节点的同时还会为Pod分配拓扑资源，并将结果写到Pod的annotations中。&lt;/p>
&lt;p>Crane-Agent在节点上Watch到Pod被调度后，从Pod的annotations中获取到拓扑分配结果，并按照用户给定的CPU绑定策略进行CPUSet的细粒度分配。&lt;/p>
&lt;p>&lt;img src="/images/topology-awareness-details.png" alt="topology-awareness-details">&lt;/p>
&lt;h3 id="cpu分配策略">CPU分配策略&lt;/h3>
&lt;p>Crane中提供了四种CPU分配策略，分别如下：&lt;/p>
&lt;ol>
&lt;li>none：该策略不进行特别的CPUSet分配，Pod会使用节点CPU共享池。&lt;/li>
&lt;li>exclusive：该策略对应kubelet的static策略，Pod会独占CPU核心，其他任何Pod都无法使用。&lt;/li>
&lt;li>numa：该策略会指定NUMA Node，Pod会使用该NUMA Node上的CPU共享池。&lt;/li>
&lt;li>immovable：该策略会将Pod固定在某些CPU核心上，但这些核心属于共享池，其他Pod仍可使用。&lt;/li>
&lt;/ol>
&lt;h2 id="开始">开始&lt;/h2>
&lt;h3 id="安装crane-agent">安装Crane-Agent&lt;/h3>
&lt;ol>
&lt;li>&lt;a href="/zh-cn/docs/getting-started/installation">参考这里&lt;/a>安装Crane-Agent&lt;/li>
&lt;li>在Crane-Agent启动参数中添加 &lt;code>--feature-gates=NodeResourceTopology=true,CraneCPUManager=true&lt;/code>开启拓扑感知调度特性。&lt;/li>
&lt;/ol>
&lt;h3 id="安装crane-scheduler">安装Crane-Scheduler&lt;/h3>
&lt;ol>
&lt;li>备份 &lt;code>/etc/kubernetes/manifests/kube-scheduler.yaml&lt;/code>&lt;/li>
&lt;/ol>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>cp /etc/kubernetes/manifests/kube-scheduler.yaml /etc/kubernetes/
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ol start="2">
&lt;li>通过修改 kube-scheduler 的配置文件（&lt;code>scheduler-config.yaml&lt;/code> ) 启用动态调度插件并配置插件参数：&lt;/li>
&lt;/ol>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-yaml" data-lang="yaml">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">apiVersion&lt;/span>: &lt;span style="color:#ae81ff">kubescheduler.config.k8s.io/v1beta2&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">kind&lt;/span>: &lt;span style="color:#ae81ff">KubeSchedulerConfiguration&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">leaderElection&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">leaderElect&lt;/span>: &lt;span style="color:#66d9ef">true&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">clientConnection&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">kubeconfig&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;REPLACE_ME_WITH_KUBE_CONFIG_PATH&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">profiles&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#f92672">schedulerName&lt;/span>: &lt;span style="color:#ae81ff">default-scheduler&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">plugins&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">preFilter&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">enabled&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#f92672">name&lt;/span>: &lt;span style="color:#ae81ff">NodeResourceTopologyMatch&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">filter&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">enabled&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#f92672">name&lt;/span>: &lt;span style="color:#ae81ff">NodeResourceTopologyMatch&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">score&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">enabled&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#f92672">name&lt;/span>: &lt;span style="color:#ae81ff">NodeResourceTopologyMatch&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">weight&lt;/span>: &lt;span style="color:#ae81ff">2&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">reserve&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">enabled&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#f92672">name&lt;/span>: &lt;span style="color:#ae81ff">NodeResourceTopologyMatch&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">preBind&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">enabled&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#f92672">name&lt;/span>: &lt;span style="color:#ae81ff">NodeResourceTopologyMatch&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ol start="3">
&lt;li>添加RBAC规则&lt;/li>
&lt;/ol>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-yaml" data-lang="yaml">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">apiVersion&lt;/span>: &lt;span style="color:#ae81ff">rbac.authorization.k8s.io/v1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">kind&lt;/span>: &lt;span style="color:#ae81ff">ClusterRole&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">metadata&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">name&lt;/span>: &lt;span style="color:#ae81ff">system:kube-scheduler:plugins&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">rules&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#f92672">apiGroups&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#ae81ff">topology.crane.io&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">resources&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#e6db74">&amp;#34;*&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">verbs&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#ae81ff">get&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#ae81ff">list&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#ae81ff">watch&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#f92672">apiGroups&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#e6db74">&amp;#34;&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">resources&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#ae81ff">pods&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">verbs&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#ae81ff">patch&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>---
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">kind&lt;/span>: &lt;span style="color:#ae81ff">ClusterRoleBinding&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">apiVersion&lt;/span>: &lt;span style="color:#ae81ff">rbac.authorization.k8s.io/v1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">metadata&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">name&lt;/span>: &lt;span style="color:#ae81ff">system:kube-scheduler:plugins&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">roleRef&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">apiGroup&lt;/span>: &lt;span style="color:#ae81ff">rbac.authorization.k8s.io&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">kind&lt;/span>: &lt;span style="color:#ae81ff">ClusterRole&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">name&lt;/span>: &lt;span style="color:#ae81ff">system:kube-scheduler:plugins&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">subjects&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#f92672">kind&lt;/span>: &lt;span style="color:#ae81ff">User&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">apiGroup&lt;/span>: &lt;span style="color:#ae81ff">rbac.authorization.k8s.io&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">name&lt;/span>: &lt;span style="color:#ae81ff">system:kube-scheduler&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ol start="4">
&lt;li>修改 &lt;code>kube-scheduler.yaml&lt;/code>并用 Crane-scheduler的镜像替换 kube-scheduler 镜像&lt;/li>
&lt;/ol>
&lt;h3 id="使用拓扑感知调度对pod进行精细化调度">使用拓扑感知调度对Pod进行精细化调度&lt;/h3>
&lt;p>正确安装组件后，每个节点均会生成NodeResourceTopology对象。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>$ kubectl get nrt
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>NAME CRANE CPU MANAGER POLICY CRANE TOPOLOGY MANAGER POLICY AGE
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>9.134.230.65 Static SingleNUMANodePodLevel 35d
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>可以看出minikube集群中节点9.134.230.65已生成对应的NRT对象，此时Crane的CPU Manager Policy为 &lt;code>Static&lt;/code>，节点默认的Topology Manager Policy为 &lt;code>SingleNUMANodePodLevel&lt;/code>，代表节点不允许跨NUMA分配资源。&lt;/p>
&lt;p>使用以下实例进行调度测试：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-yaml" data-lang="yaml">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">apiVersion&lt;/span>: &lt;span style="color:#ae81ff">apps/v1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">kind&lt;/span>: &lt;span style="color:#ae81ff">Deployment&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">metadata&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">name&lt;/span>: &lt;span style="color:#ae81ff">nginx-deployment&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">labels&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">app&lt;/span>: &lt;span style="color:#ae81ff">nginx&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">spec&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">replicas&lt;/span>: &lt;span style="color:#ae81ff">1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">selector&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">matchLabels&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">app&lt;/span>: &lt;span style="color:#ae81ff">nginx&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">template&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">metadata&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">annotations&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">topology.crane.io/topology-awareness&lt;/span>: &lt;span style="color:#e6db74">&amp;#39;true&amp;#39;&lt;/span> &lt;span style="color:#75715e"># 添加注解，表示Pod需要感知CPU拓扑，资源分配不允许跨NUMA。若不指定，则拓扑策略默认继承节点上的topology.crane.io/topology-awareness标签&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">topology.crane.io/cpu-policy&lt;/span>: &lt;span style="color:#e6db74">&amp;#39;exclusive&amp;#39;&lt;/span> &lt;span style="color:#75715e"># 添加注解，表示Pod的CPU分配策略为exclusive策略。&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">labels&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">app&lt;/span>: &lt;span style="color:#ae81ff">nginx&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">spec&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">containers&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#f92672">image&lt;/span>: &lt;span style="color:#ae81ff">nginx&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">name&lt;/span>: &lt;span style="color:#ae81ff">nginx&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">resources&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">limits&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">cpu&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;2&amp;#34;&lt;/span> &lt;span style="color:#75715e"># 需要limits.cpu值，如果要开启绑核，则该值必须等于requests.cpu。&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">memory&lt;/span>: &lt;span style="color:#ae81ff">2Gi&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>从annotations中查看Pod的拓扑分配结果。发现Pod在NUMA Node0上被分配了2个CPU核心。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>$ kubectl get pod -o custom-columns&lt;span style="color:#f92672">=&lt;/span>name:metadata.name,topology-result:metadata.annotations.&lt;span style="color:#e6db74">&amp;#34;topology\.crane\.io/topology-result&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>name topology-result
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>nginx-deployment-754d99dcdf-mtcdp &lt;span style="color:#f92672">[{&lt;/span>&lt;span style="color:#e6db74">&amp;#34;name&amp;#34;&lt;/span>:&lt;span style="color:#e6db74">&amp;#34;node0&amp;#34;&lt;/span>,&lt;span style="color:#e6db74">&amp;#34;type&amp;#34;&lt;/span>:&lt;span style="color:#e6db74">&amp;#34;Node&amp;#34;&lt;/span>,&lt;span style="color:#e6db74">&amp;#34;resources&amp;#34;&lt;/span>:&lt;span style="color:#f92672">{&lt;/span>&lt;span style="color:#e6db74">&amp;#34;capacity&amp;#34;&lt;/span>:&lt;span style="color:#f92672">{&lt;/span>&lt;span style="color:#e6db74">&amp;#34;cpu&amp;#34;&lt;/span>:&lt;span style="color:#e6db74">&amp;#34;2&amp;#34;&lt;/span>&lt;span style="color:#f92672">}}}]&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>Docs: Crane-scheduler</title><link>/zh-cn/docs/tutorials/scheduling-pods-based-on-actual-node-load/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/zh-cn/docs/tutorials/scheduling-pods-based-on-actual-node-load/</guid><description>
&lt;p>Crane-scheduler 是一组基于&lt;a href="https://kubernetes.io/docs/concepts/scheduling-eviction/scheduling-framework/">scheduler framework&lt;/a>的调度插件， 包含：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="/zh-cn/docs/tutorials/dynamic-scheduler-plugin">Dynamic scheduler：负载感知调度器插件&lt;/a>&lt;/li>
&lt;/ul>
&lt;h2 id="开始">开始&lt;/h2>
&lt;h3 id="安装-prometheus">安装 Prometheus&lt;/h3>
&lt;p>确保你的 Kubernetes 集群已安装 Prometheus。如果没有，请参考&lt;a href="https://github.com/gocrane/fadvisor/blob/main/README.md#prerequests">Install Prometheus&lt;/a>.&lt;/p>
&lt;h3 id="配置-prometheus-规则">配置 Prometheus 规则&lt;/h3>
&lt;p>配置 Prometheus 的规则以获取预期的聚合数据：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-yaml" data-lang="yaml">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">apiVersion&lt;/span>: &lt;span style="color:#ae81ff">monitoring.coreos.com/v1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">kind&lt;/span>: &lt;span style="color:#ae81ff">PrometheusRule&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">metadata&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">name&lt;/span>: &lt;span style="color:#ae81ff">example-record&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">spec&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">groups&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#f92672">name&lt;/span>: &lt;span style="color:#ae81ff">cpu_mem_usage_active&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">interval&lt;/span>: &lt;span style="color:#ae81ff">30s&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">rules&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#f92672">record&lt;/span>: &lt;span style="color:#ae81ff">cpu_usage_active&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">expr&lt;/span>: &lt;span style="color:#ae81ff">100&lt;/span> - &lt;span style="color:#ae81ff">(avg by (instance) (irate(node_cpu_seconds_total{mode=&amp;#34;idle&amp;#34;}[30s])) * 100)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#f92672">record&lt;/span>: &lt;span style="color:#ae81ff">mem_usage_active&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">expr&lt;/span>: &lt;span style="color:#ae81ff">100&lt;/span>&lt;span style="color:#75715e">*(1-node_memory_MemAvailable_bytes/node_memory_MemTotal_bytes)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#f92672">name&lt;/span>: &lt;span style="color:#ae81ff">cpu-usage-5m&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">interval&lt;/span>: &lt;span style="color:#ae81ff">5m&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">rules&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#f92672">record&lt;/span>: &lt;span style="color:#ae81ff">cpu_usage_max_avg_1h&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">expr&lt;/span>: &lt;span style="color:#ae81ff">max_over_time(cpu_usage_avg_5m[1h])&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#f92672">record&lt;/span>: &lt;span style="color:#ae81ff">cpu_usage_max_avg_1d&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">expr&lt;/span>: &lt;span style="color:#ae81ff">max_over_time(cpu_usage_avg_5m[1d])&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#f92672">name&lt;/span>: &lt;span style="color:#ae81ff">cpu-usage-1m&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">interval&lt;/span>: &lt;span style="color:#ae81ff">1m&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">rules&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#f92672">record&lt;/span>: &lt;span style="color:#ae81ff">cpu_usage_avg_5m&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">expr&lt;/span>: &lt;span style="color:#ae81ff">avg_over_time(cpu_usage_active[5m])&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#f92672">name&lt;/span>: &lt;span style="color:#ae81ff">mem-usage-5m&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">interval&lt;/span>: &lt;span style="color:#ae81ff">5m&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">rules&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#f92672">record&lt;/span>: &lt;span style="color:#ae81ff">mem_usage_max_avg_1h&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">expr&lt;/span>: &lt;span style="color:#ae81ff">max_over_time(mem_usage_avg_5m[1h])&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#f92672">record&lt;/span>: &lt;span style="color:#ae81ff">mem_usage_max_avg_1d&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">expr&lt;/span>: &lt;span style="color:#ae81ff">max_over_time(mem_usage_avg_5m[1d])&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#f92672">name&lt;/span>: &lt;span style="color:#ae81ff">mem-usage-1m&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">interval&lt;/span>: &lt;span style="color:#ae81ff">1m&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">rules&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#f92672">record&lt;/span>: &lt;span style="color:#ae81ff">mem_usage_avg_5m&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">expr&lt;/span>: &lt;span style="color:#ae81ff">avg_over_time(mem_usage_active[5m])&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>!!! warning &amp;ldquo;️Troubleshooting&amp;rdquo;&lt;/p>
&lt;pre>&lt;code> Prometheus 的采样间隔必须小于30秒，不然可能会导致规则无法正常生效。如：`cpu_usage_active`。
&lt;/code>&lt;/pre>
&lt;h3 id="安装-crane-scheduler">安装 Crane-scheduler&lt;/h3>
&lt;p>有两种选择：&lt;/p>
&lt;ul>
&lt;li>安装 Crane-scheduler 作为第二个调度器&lt;/li>
&lt;li>用 Crane-scheduler 替换原生 Kube-scheduler&lt;/li>
&lt;/ul>
&lt;h4 id="安装-crane-scheduler-作为第二个调度器">安装 Crane-scheduler 作为第二个调度器&lt;/h4>
&lt;p>=== &amp;ldquo;Main&amp;rdquo;&lt;/p>
&lt;pre>&lt;code> ```bash
helm repo add crane https://gocrane.github.io/helm-charts
helm install scheduler -n crane-system --create-namespace --set global.prometheusAddr=&amp;quot;REPLACE_ME_WITH_PROMETHEUS_ADDR&amp;quot; crane/scheduler
```
&lt;/code>&lt;/pre>
&lt;p>=== &amp;ldquo;Mirror&amp;rdquo;&lt;/p>
&lt;pre>&lt;code> ```bash
helm repo add crane https://finops-helm.pkg.coding.net/gocrane/gocrane
helm install scheduler -n crane-system --create-namespace --set global.prometheusAddr=&amp;quot;REPLACE_ME_WITH_PROMETHEUS_ADDR&amp;quot; crane/scheduler
```
&lt;/code>&lt;/pre>
&lt;h4 id="用-crane-scheduler-替换原生-kube-scheduler">用 Crane-scheduler 替换原生 Kube-scheduler&lt;/h4>
&lt;ol>
&lt;li>备份&lt;code>/etc/kubernetes/manifests/kube-scheduler.yaml&lt;/code>&lt;/li>
&lt;/ol>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>cp /etc/kubernetes/manifests/kube-scheduler.yaml /etc/kubernetes/
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ol start="2">
&lt;li>通过修改 kube-scheduler 的配置文件（&lt;code>scheduler-config.yaml&lt;/code> ) 启用动态调度插件并配置插件参数：&lt;/li>
&lt;/ol>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-yaml" data-lang="yaml">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">apiVersion&lt;/span>: &lt;span style="color:#ae81ff">kubescheduler.config.k8s.io/v1beta2&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">kind&lt;/span>: &lt;span style="color:#ae81ff">KubeSchedulerConfiguration&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>...
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">profiles&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>- &lt;span style="color:#f92672">schedulerName&lt;/span>: &lt;span style="color:#ae81ff">default-scheduler&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">plugins&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">filter&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">enabled&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#f92672">name&lt;/span>: &lt;span style="color:#ae81ff">Dynamic&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">score&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">enabled&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#f92672">name&lt;/span>: &lt;span style="color:#ae81ff">Dynamic&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">weight&lt;/span>: &lt;span style="color:#ae81ff">3&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">pluginConfig&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#f92672">name&lt;/span>: &lt;span style="color:#ae81ff">Dynamic&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">args&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">policyConfigPath&lt;/span>: &lt;span style="color:#ae81ff">/etc/kubernetes/policy.yaml&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>...
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ol start="3">
&lt;li>新建&lt;code>/etc/kubernetes/policy.yaml&lt;/code>，用作动态插件的调度策略：&lt;/li>
&lt;/ol>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-yaml" data-lang="yaml">&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">apiVersion&lt;/span>: &lt;span style="color:#ae81ff">scheduler.policy.crane.io/v1alpha1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">kind&lt;/span>: &lt;span style="color:#ae81ff">DynamicSchedulerPolicy&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">spec&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">syncPolicy&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">##cpu usage&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#f92672">name&lt;/span>: &lt;span style="color:#ae81ff">cpu_usage_avg_5m&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">period&lt;/span>: &lt;span style="color:#ae81ff">3m&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#f92672">name&lt;/span>: &lt;span style="color:#ae81ff">cpu_usage_max_avg_1h&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">period&lt;/span>: &lt;span style="color:#ae81ff">15m&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#f92672">name&lt;/span>: &lt;span style="color:#ae81ff">cpu_usage_max_avg_1d&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">period&lt;/span>: &lt;span style="color:#ae81ff">3h&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">##memory usage&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#f92672">name&lt;/span>: &lt;span style="color:#ae81ff">mem_usage_avg_5m&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">period&lt;/span>: &lt;span style="color:#ae81ff">3m&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#f92672">name&lt;/span>: &lt;span style="color:#ae81ff">mem_usage_max_avg_1h&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">period&lt;/span>: &lt;span style="color:#ae81ff">15m&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#f92672">name&lt;/span>: &lt;span style="color:#ae81ff">mem_usage_max_avg_1d&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">period&lt;/span>: &lt;span style="color:#ae81ff">3h&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">predicate&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">##cpu usage&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#f92672">name&lt;/span>: &lt;span style="color:#ae81ff">cpu_usage_avg_5m&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">maxLimitPecent&lt;/span>: &lt;span style="color:#ae81ff">0.65&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#f92672">name&lt;/span>: &lt;span style="color:#ae81ff">cpu_usage_max_avg_1h&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">maxLimitPecent&lt;/span>: &lt;span style="color:#ae81ff">0.75&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">##memory usage&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#f92672">name&lt;/span>: &lt;span style="color:#ae81ff">mem_usage_avg_5m&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">maxLimitPecent&lt;/span>: &lt;span style="color:#ae81ff">0.65&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#f92672">name&lt;/span>: &lt;span style="color:#ae81ff">mem_usage_max_avg_1h&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">maxLimitPecent&lt;/span>: &lt;span style="color:#ae81ff">0.75&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">priority&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">##cpu usage&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#f92672">name&lt;/span>: &lt;span style="color:#ae81ff">cpu_usage_avg_5m&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">weight&lt;/span>: &lt;span style="color:#ae81ff">0.2&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#f92672">name&lt;/span>: &lt;span style="color:#ae81ff">cpu_usage_max_avg_1h&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">weight&lt;/span>: &lt;span style="color:#ae81ff">0.3&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#f92672">name&lt;/span>: &lt;span style="color:#ae81ff">cpu_usage_max_avg_1d&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">weight&lt;/span>: &lt;span style="color:#ae81ff">0.5&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">##memory usage&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#f92672">name&lt;/span>: &lt;span style="color:#ae81ff">mem_usage_avg_5m&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">weight&lt;/span>: &lt;span style="color:#ae81ff">0.2&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#f92672">name&lt;/span>: &lt;span style="color:#ae81ff">mem_usage_max_avg_1h&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">weight&lt;/span>: &lt;span style="color:#ae81ff">0.3&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#f92672">name&lt;/span>: &lt;span style="color:#ae81ff">mem_usage_max_avg_1d&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">weight&lt;/span>: &lt;span style="color:#ae81ff">0.5&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">hotValue&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#f92672">timeRange&lt;/span>: &lt;span style="color:#ae81ff">5m&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">count&lt;/span>: &lt;span style="color:#ae81ff">5&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#f92672">timeRange&lt;/span>: &lt;span style="color:#ae81ff">1m&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">count&lt;/span>: &lt;span style="color:#ae81ff">2&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ol start="4">
&lt;li>修改&lt;code>kube-scheduler.yaml&lt;/code>并用 Crane-scheduler的镜像替换 kube-scheduler 镜像：&lt;/li>
&lt;/ol>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-yaml" data-lang="yaml">&lt;span style="display:flex;">&lt;span>...
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">image&lt;/span>: &lt;span style="color:#ae81ff">docker.io/gocrane/crane-scheduler:0.0.23&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>...
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ol start="5">
&lt;li>
&lt;p>安装&lt;a href="https://github.com/gocrane/crane-scheduler/tree/main/deploy/controller">crane-scheduler-controller&lt;/a>：
=== &amp;ldquo;Main&amp;rdquo;&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span> kubectl apply -f https://raw.githubusercontent.com/gocrane/crane-scheduler/main/deploy/controller/rbac.yaml
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> kubectl apply -f https://raw.githubusercontent.com/gocrane/crane-scheduler/main/deploy/controller/deployment.yaml
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;/ol>
&lt;p>=== &amp;ldquo;Mirror&amp;rdquo;&lt;/p>
&lt;pre>&lt;code> ```bash
kubectl apply -f https://gitee.com/finops/crane-scheduler/raw/main/deploy/controller/rbac.yaml
kubectl apply -f https://gitee.com/finops/crane-scheduler/raw/main/deploy/controller/deployment.yaml
```
&lt;/code>&lt;/pre>
&lt;h3 id="使用-crane-scheduler-调度-pod">使用 Crane-scheduler 调度 Pod&lt;/h3>
&lt;p>使用以下示例测试 Crane-scheduler ：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-yaml" data-lang="yaml">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">apiVersion&lt;/span>: &lt;span style="color:#ae81ff">apps/v1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">kind&lt;/span>: &lt;span style="color:#ae81ff">Deployment&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">metadata&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">name&lt;/span>: &lt;span style="color:#ae81ff">cpu-stress&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">spec&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">selector&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">matchLabels&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">app&lt;/span>: &lt;span style="color:#ae81ff">cpu-stress&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">replicas&lt;/span>: &lt;span style="color:#ae81ff">1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">template&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">metadata&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">labels&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">app&lt;/span>: &lt;span style="color:#ae81ff">cpu-stress&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">spec&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">schedulerName&lt;/span>: &lt;span style="color:#ae81ff">crane-scheduler&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">hostNetwork&lt;/span>: &lt;span style="color:#66d9ef">true&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">tolerations&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#f92672">key&lt;/span>: &lt;span style="color:#ae81ff">node.kubernetes.io/network-unavailable&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">operator&lt;/span>: &lt;span style="color:#ae81ff">Exists&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">effect&lt;/span>: &lt;span style="color:#ae81ff">NoSchedule&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">containers&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#f92672">name&lt;/span>: &lt;span style="color:#ae81ff">stress&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">image&lt;/span>: &lt;span style="color:#ae81ff">docker.io/gocrane/stress:latest&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">command&lt;/span>: [&lt;span style="color:#e6db74">&amp;#34;stress&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;-c&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;1&amp;#34;&lt;/span>]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">resources&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">requests&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">memory&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;1Gi&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">cpu&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;1&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">limits&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">memory&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;1Gi&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">cpu&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;1&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>!!! Note&lt;/p>
&lt;pre>&lt;code>如果想将`crane-scheduler`用作默认调度器，请将`crane-scheduler`更改为`default-scheduler`。
&lt;/code>&lt;/pre>
&lt;p>如果测试 pod 调度成功，将会有以下事件：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>Type Reason Age From Message
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>---- ------ ---- ---- -------
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Normal Scheduled 28s crane-scheduler Successfully assigned default/cpu-stress-7669499b57-zmrgb to vm-162-247-ubuntu
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>Docs: DSP 预测算法</title><link>/zh-cn/docs/tutorials/timeseriees-forecasting-by-dsp/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/zh-cn/docs/tutorials/timeseriees-forecasting-by-dsp/</guid><description>
&lt;p>Crane使用在数字信号处理（Digital Signal Processing）领域中常用的的&lt;code>离散傅里叶变换&lt;/code>、&lt;code>自相关函数&lt;/code>等手段，识别、预测周期性的时间序列。&lt;/p>
&lt;p>本文将介绍DSP算法的实现流程和参数设置，以便帮助大家了解算法背后的原理，并将它应用到实际场景中。 （相关代码位于&lt;code>pkg/prediction/dsp&lt;/code>目录下）&lt;/p>
&lt;h2 id="流程">流程&lt;/h2>
&lt;p>&lt;img src="/images/algorithm/dsp/dsp.png" alt="">&lt;/p>
&lt;h3 id="预处理">预处理&lt;/h3>
&lt;h4 id="填充缺失数据">填充缺失数据&lt;/h4>
&lt;p>监控数据在某些时间点上缺失是很常见的现象，Crane会根据前后的数据对缺失的采样点进行填充。做法如下：&lt;/p>
&lt;p>假设第$m$个与第$n$个采样点之间采样数据缺失（$m+1 &amp;lt; n$）,设在$m$和$n$点的采样值分别为$v_m$和$v_n$，令$$\Delta = {v_n-v_m \over n-m}$$，则$m$和$n$之间的填充数据依次为$v_m+\Delta , v_m+2\Delta , &amp;hellip;$&lt;/p>
&lt;p>&lt;img src="/images/algorithm/dsp/missing_data_fill.png" alt="">&lt;/p>
&lt;h4 id="去除异常点">去除异常点&lt;/h4>
&lt;p>监控数据中偶尔会出现一些极端的异常数据点，导致这些异常点（outliers）的原因有很多，例如：&lt;/p>
&lt;ol>
&lt;li>监控系统用0值填充缺失的采样点；&lt;/li>
&lt;li>被监控组件由于自身的bug上报了错误的指标数据；&lt;/li>
&lt;li>应用启动时会消耗远超正常运行时的资源&lt;/li>
&lt;/ol>
&lt;p>这些极端的异常点对于信号的周期判断会造成干扰，需要进行去除。做法如下：&lt;/p>
&lt;p>选取实际序列中所有采样点的$P99.9$和$P0.1$，分别作为上、下限阈值，如果某个采样值低于下限或者高于上限，将采样点的值设置为前一个采样值。&lt;/p>
&lt;p>&lt;img src="/images/algorithm/dsp/remove_outliers.png" alt="">&lt;/p>
&lt;h4 id="离散傅里叶变换">离散傅里叶变换&lt;/h4>
&lt;p>对监控的时间序列（设长度为$N$）做快速离散傅里叶变换（FFT），得到信号的频谱图（spectrogram），频谱图直观地表现为在各个离散点$k$处的「冲击」。
冲击的高度为$k$对应周期分量的「幅度」，$k$的取值范围$(0,1,2, &amp;hellip; N-1)$。&lt;/p>
&lt;p>$k = 0$对应信号的「直流分量」，对于周期没有影响，因此忽略。&lt;/p>
&lt;p>由于离散傅里叶变换后的频谱序列前一半和后一半是共轭对称的，反映到频谱图上就是关于轴对称，因此只看前一半$N/2$即可。&lt;/p>
&lt;p>$k$所对应的周期$$T = {N \over k} \bullet SampleInterval$$&lt;/p>
&lt;p>要观察一个信号是不是以$T$为周期，至少需要观察两倍的$T$的长度，因此通过长度为$N$的序列能够识别出的最长周期为$N/2$。所以可以忽略$k = 1$。&lt;/p>
&lt;p>至此，$k$的取值范围为$(2, 3, &amp;hellip; , N/2)$，对应的周期为$N/2, N/3, &amp;hellip;$，这也就是FFT能够提供的周期信息的「分辨率」。如果一个信号的周期没有落到$N/k$上，它会散布到整个频域，导致「频率泄漏」。
好在在实际生产环境中，我们通常遇到的应用（尤其是在线业务），如果有规律，都是以「天」为周期的，某些业务可能会有所谓的「周末」效应，即周末和工作日不太一样，如果扩大到「周」的粒度去观察，它们同样具有良好的周期性。&lt;/p>
&lt;p>Crane没有尝试发现任意长度的周期，而是指定几个固定的周期长度（$1d、7d$）去判断。并通过截取、填充的方式，保证序列的长度$N$为待检测周期$T$的整倍数，例如：$T=1d，N=3d；T=7d，N=14d$。&lt;/p>
&lt;p>我们从生产环境中抓取了一些应用的监控指标，保存为csv格式，放到&lt;code>pkg/prediction/dsp/test_data&lt;/code>目录下。
例如，&lt;code>input0.csv&lt;/code>文件包括了一个应用连续8天的CPU监控数据，对应的时间序列如下图：&lt;/p>
&lt;p>&lt;img src="/images/algorithm/dsp/input0.png" alt="">&lt;/p>
&lt;p>我们看到，尽管每天的数据不尽相同，但大体「模式」还是基本一致的。&lt;/p>
&lt;p>对它做FFT，会得到下面的频谱图：&lt;/p>
&lt;p>&lt;img src="/images/algorithm/dsp/spectrum.png" alt="">&lt;/p>
&lt;p>我们发现在几个点上的「幅值」明显高于其它点，这些点便可以作为我们的「候选周期」，待进一步的验证。&lt;/p>
&lt;p>上面是我们通过直觉判断的，Crane是如何挑选「候选周期」的呢？&lt;/p>
&lt;ol>
&lt;li>
&lt;p>对原始序列$\vec x(n)$进行一个随机排列后得到序列$\vec x&amp;rsquo;(n)$，再对$\vec x&amp;rsquo;(n)$做FFT得到$\vec X&amp;rsquo;(k)$，令$P_{max} = argmax|\vec X&amp;rsquo;(k)|$。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>重复100次上述操作，得到100个$P_{max}$，取$P99$作为阈值$P_{threshold}$。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>对原始序列$\vec x(n)$做FFT得到$\vec X(f)$，遍历$k = 2, 3, &amp;hellip;$，如果$P_k = |X(k)| &amp;gt; P_{threshold}$，则将$k$加入候选周期。&lt;/p>
&lt;/li>
&lt;/ol>
&lt;h4 id="循环自相关函数">循环自相关函数&lt;/h4>
&lt;p>自相关函数（Auto Correlation Function，ACF）是一个信号于其自身在不同时间点的互相关。通俗的讲，它就是两次观察之间的相似度对它们之间的时间差的函数。&lt;/p>
&lt;p>Crane使用循环自相关函数（Circular ACF），先对长度为$N$的时间序列以$N$为周期做扩展，也就是在$&amp;hellip;, [-N, -1], [N, 2N-1], &amp;hellip;$区间上复制$\vec x(n)$，得到一个新的序列$\vec x&amp;rsquo;(n)$。
再依次计算将$\vec x&amp;rsquo;(n)$依次平移$k=1,2,3,&amp;hellip;N/2$后的$\vec x&amp;rsquo;(n+k)$与$\vec x&amp;rsquo;(n)$的相关系数&lt;/p>
&lt;p>$$r_k={\displaystyle\sum_{i=-k}^{N-k-1} (x_i-\mu)(x_{i+k}-\mu) \over \displaystyle\sum_{i=0}^{N-1} (x_i-\mu)^2}\ \ \ \mu: mean$$&lt;/p>
&lt;p>Crane没有直接使用上面的定义去计算ACF，而是根据下面的公式，通过两次$(I)FFT$，从而能够在$O(nlogn)$的时间内完成ACF的计算。
$$\vec r = IFFT(|FFT({\vec x - \mu \over \sigma})|^2)\ \ \ \mu: mean,\ \sigma: standard\ deviation$$&lt;/p>
&lt;p>ACF的图像如下所示，横轴代表信号平移的时间长度$k$；纵轴代表自相关系数$r_k$，反应了平移信号与原始信号的「相似」程度。&lt;/p>
&lt;p>&lt;img src="/images/algorithm/dsp/acf.png" alt="">&lt;/p>
&lt;p>Crane会依次验证每一个候选周期对应的自相关系数是否位于「山顶」上；并且选择对应「最高峰」的那个候选周期为整个时间序列的主周期（基波周期），并以此为基础进行预测。&lt;/p>
&lt;p>如何判断「山顶」？&lt;/p>
&lt;p>Crane在两侧个各选取一段曲线，分别做线性回归，当回归后左、右的直线斜率分别大于、小于零时，则认为这个点是在一个「山顶」上。&lt;/p>
&lt;p>&lt;img src="/images/algorithm/dsp/linear_regression.png" alt="">&lt;/p>
&lt;h4 id="预测">预测&lt;/h4>
&lt;p>根据上一步得到的主周期，Crane提供了两种方式去拟合（预测）下一个周期的时序数据
&lt;strong>maxValue&lt;/strong>&lt;/p>
&lt;p>选取过去几个周期中相同时刻$t$（例如：下午6:00）中的最大值，作为下一个周期$t$时刻的预测值。&lt;/p>
&lt;p>&lt;img src="/images/algorithm/dsp/max_value.png" alt="">
&lt;strong>fft&lt;/strong>&lt;/p>
&lt;p>对原始时间序列做FFT得到频谱序列，去除「高频噪声」后，再做IFFT（逆快速傅里叶变换），将得到的时间序列作为下一个周期的预测结果。&lt;/p>
&lt;h2 id="应用">应用&lt;/h2>
&lt;p>Crane提供了&lt;code>TimeSeriesPrediction&lt;/code>，通过这个CRD，用户可以对各种时间序列进行预测，例如工作负责的CPU利用率、应用的QPS等等。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-yaml" data-lang="yaml">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">apiVersion&lt;/span>: &lt;span style="color:#ae81ff">prediction.crane.io/v1alpha1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">kind&lt;/span>: &lt;span style="color:#ae81ff">TimeSeriesPrediction&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">metadata&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">name&lt;/span>: &lt;span style="color:#ae81ff">tsp-workload-dsp&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">namespace&lt;/span>: &lt;span style="color:#ae81ff">default&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">spec&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">targetRef&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">apiVersion&lt;/span>: &lt;span style="color:#ae81ff">apps/v1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">kind&lt;/span>: &lt;span style="color:#ae81ff">Deployment&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">name&lt;/span>: &lt;span style="color:#ae81ff">test&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">namespace&lt;/span>: &lt;span style="color:#ae81ff">default&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">predictionWindowSeconds&lt;/span>: &lt;span style="color:#ae81ff">7200&lt;/span> &lt;span style="color:#75715e"># 提供未来7200秒（2小时）的预测数据。Crane会把预测数据写到status中。&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">predictionMetrics&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#f92672">resourceIdentifier&lt;/span>: &lt;span style="color:#ae81ff">workload-cpu&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">type&lt;/span>: &lt;span style="color:#ae81ff">ExpressionQuery&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">expressionQuery&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">expression&lt;/span>: &lt;span style="color:#e6db74">&amp;#39;sum (irate (container_cpu_usage_seconds_total{container!=&amp;#34;&amp;#34;,image!=&amp;#34;&amp;#34;,container!=&amp;#34;POD&amp;#34;,pod=~&amp;#34;^test-.*$&amp;#34;}[1m]))&amp;#39;&lt;/span> &lt;span style="color:#75715e"># 获取历史监控数据的查询语句&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">algorithm&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">algorithmType&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;dsp&amp;#34;&lt;/span> &lt;span style="color:#75715e"># 指定dsp为预测算法&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">dsp&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">sampleInterval&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;60s&amp;#34;&lt;/span> &lt;span style="color:#75715e"># 监控数据的采样间隔为1分钟&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">historyLength&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;15d&amp;#34;&lt;/span> &lt;span style="color:#75715e"># 拉取过去15天的监控指标作为预测的依据&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">estimators&lt;/span>: &lt;span style="color:#75715e"># 指定预测方式，包括&amp;#39;maxValue&amp;#39;和&amp;#39;fft&amp;#39;，每一类可以指定多个estimator，配置不同的参数，crane会选取一个拟合度最高的去产生预测结果。如果不指定的话，默认使用&amp;#39;fft&amp;#39;。&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># maxValue:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># - marginFraction: &amp;#34;0.1&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">fft&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#f92672">marginFraction&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;0.2&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">lowAmplitudeThreshold&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;1.0&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">highFrequencyThreshold&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;0.05&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">minNumOfSpectrumItems&lt;/span>: &lt;span style="color:#ae81ff">10&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">maxNumOfSpectrumItems&lt;/span>: &lt;span style="color:#ae81ff">20&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>上面示例中的一些dsp参数含义如下：&lt;/p>
&lt;p>&lt;strong>maxValue&lt;/strong>&lt;/p>
&lt;p>&lt;code>marginFraction&lt;/code>: 拟合出下一个周期的序列后，将每一个预测值乘以&lt;code>1 + marginFraction&lt;/code>，例如&lt;code>marginFraction = 0.1&lt;/code>,就是乘以1.1。&lt;code>marginFraction&lt;/code>的作用是将预测数据进行一定比例的放大（或缩小）。&lt;/p>
&lt;p>&lt;strong>fft&lt;/strong>&lt;/p>
&lt;p>&lt;code>marginFraction&lt;/code>: 拟合出下一个周期的序列后，将每一个预测值乘以&lt;code>1 + marginFraction&lt;/code>，例如&lt;code>marginFraction = 0.1&lt;/code>,就是乘以1.1。&lt;code>marginFraction&lt;/code>的作用是将预测数据进行一定比例的放大（或缩小）。&lt;/p>
&lt;p>&lt;code>lowAmplitudeThreshold&lt;/code>: 频谱幅度下限，所有幅度低于这个下限的频率分量将被滤除。&lt;/p>
&lt;p>&lt;code>highFrequencyThreshold&lt;/code>: 频率上限，所有频率高于这个上限的频率分量将被滤除。单位Hz，例如如果想忽略长度小于1小时的周期分量，设置&lt;code>highFrequencyThreshold = 1/3600&lt;/code>。&lt;/p>
&lt;p>&lt;code>minNumOfSpectrumItems&lt;/code>: 至少保留频率分量的个数。&lt;/p>
&lt;p>&lt;code>maxNumOfSpectrumItems&lt;/code>：至多保留频率分量的个数。&lt;/p>
&lt;p>简单来说，保留频率分量的数量越少、频率上限越低、频谱幅度下限越高，预测出来的曲线越光滑，但会丢失一些细节；反之，曲线毛刺越多，保留更多细节。&lt;/p>
&lt;p>下面是对同一时段预测的两条曲线，蓝色、绿色的&lt;code>highFrequencyThreshold&lt;/code>分别为$0.01$和$0.001$，蓝色曲线过滤掉了更多的高频分量，因此更为平滑。&lt;/p>
&lt;p>&lt;img src="/images/algorithm/dsp/lft_0_001.png" alt=""> &lt;img src="/images/algorithm/dsp/lft_0_01.png" alt="">&lt;/p>
&lt;p>并没有一套参数配置适合所有的时间序列，通常需要根据应用指标的特点，去调整算法参数，以期获得最佳的预测效果。
Crane提供了一个web接口，使用者可以在调整参数后，直观的看到预测效果，使用步骤如下：&lt;/p>
&lt;ol>
&lt;li>修改&lt;code>TimeSeriesPrediction&lt;/code>中的&lt;code>estimators&lt;/code>的参数。&lt;/li>
&lt;li>访问craned http server的&lt;code>api/prediction/debug/&amp;lt;namespace&amp;gt;/&amp;lt;timeseries prediction name&amp;gt;&lt;/code>，查看参数效果（如下图）。&lt;/li>
&lt;/ol>
&lt;p>&lt;img src="/images/algorithm/dsp/dsp_debug.png" alt="">&lt;/p>
&lt;p>上述步骤可多次执行，直到得到满意的预测效果。&lt;/p>
&lt;p>&lt;strong>通过port-forward进行本地调试&lt;/strong>&lt;/p>
&lt;p>craned http server的端口通过craned启动参数&lt;code>--server-bind-port&lt;/code>设置，默认为&lt;code>8082&lt;/code>。&lt;/p>
&lt;p>打开终端，&lt;/p>
&lt;pre tabindex="0">&lt;code>$kubectl -n crane-system port-forward service/craned 8082:8082
Forwarding from 127.0.0.1:8082 -&amp;gt; 8082
Forwarding from [::1]:8082 -&amp;gt; 8082
&lt;/code>&lt;/pre>&lt;p>打开浏览器，访问&lt;code>http://localhost:8082/api/prediction/debug/&amp;lt;namespace&amp;gt;/&amp;lt;timeseries prediction name&amp;gt;&lt;/code>&lt;/p></description></item><item><title>Docs: Effective HorizontalPodAutoscaler</title><link>/zh-cn/docs/tutorials/using-effective-hpa-to-scaling-with-effectiveness/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/zh-cn/docs/tutorials/using-effective-hpa-to-scaling-with-effectiveness/</guid><description>
&lt;p>EffectiveHorizontalPodAutoscaler（简称 EHPA）是 Crane 提供的弹性伸缩产品，它基于社区 HPA 做底层的弹性控制，支持更丰富的弹性触发策略（预测，观测，周期），让弹性更加高效，并保障了服务的质量。&lt;/p>
&lt;ul>
&lt;li>提前扩容，保证服务质量：通过算法预测未来的流量洪峰提前扩容，避免扩容不及时导致的雪崩和服务稳定性故障。&lt;/li>
&lt;li>减少无效缩容：通过预测未来可减少不必要的缩容，稳定工作负载的资源使用率，消除突刺误判。&lt;/li>
&lt;li>支持 Cron 配置：支持 Cron-based 弹性配置，应对大促等异常流量洪峰。&lt;/li>
&lt;li>兼容社区：使用社区 HPA 作为弹性控制的执行层，能力完全兼容社区。&lt;/li>
&lt;/ul>
&lt;h2 id="产品功能">产品功能&lt;/h2>
&lt;p>一个简单的 EHPA yaml 文件如下：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-yaml" data-lang="yaml">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">apiVersion&lt;/span>: &lt;span style="color:#ae81ff">autoscaling.crane.io/v1alpha1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">kind&lt;/span>: &lt;span style="color:#ae81ff">EffectiveHorizontalPodAutoscaler&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">metadata&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">name&lt;/span>: &lt;span style="color:#ae81ff">php-apache&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">spec&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">scaleTargetRef&lt;/span>: &lt;span style="color:#75715e">#(1)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">apiVersion&lt;/span>: &lt;span style="color:#ae81ff">apps/v1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">kind&lt;/span>: &lt;span style="color:#ae81ff">Deployment&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">name&lt;/span>: &lt;span style="color:#ae81ff">php-apache&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">minReplicas&lt;/span>: &lt;span style="color:#ae81ff">1&lt;/span> &lt;span style="color:#75715e">#(2)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">maxReplicas&lt;/span>: &lt;span style="color:#ae81ff">10&lt;/span> &lt;span style="color:#75715e">#(3)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">scaleStrategy&lt;/span>: &lt;span style="color:#ae81ff">Auto&lt;/span> &lt;span style="color:#75715e">#(4)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">metrics&lt;/span>: &lt;span style="color:#75715e">#(5)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#f92672">type&lt;/span>: &lt;span style="color:#ae81ff">Resource&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">resource&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">name&lt;/span>: &lt;span style="color:#ae81ff">cpu&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">target&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">type&lt;/span>: &lt;span style="color:#ae81ff">Utilization&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">averageUtilization&lt;/span>: &lt;span style="color:#ae81ff">50&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">prediction&lt;/span>: &lt;span style="color:#75715e">#(6)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">predictionWindowSeconds&lt;/span>: &lt;span style="color:#ae81ff">3600&lt;/span> &lt;span style="color:#75715e">#(7)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">predictionAlgorithm&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">algorithmType&lt;/span>: &lt;span style="color:#ae81ff">dsp&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">dsp&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">sampleInterval&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;60s&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">historyLength&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;3d&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ol>
&lt;li>ScaleTargetRef 配置你希望弹性的工作负载。&lt;/li>
&lt;li>MinReplicas 指定了自动缩容的最小值。&lt;/li>
&lt;li>MaxReplicas 指定了自动扩容的最大值。&lt;/li>
&lt;li>ScaleStrategy 定义了弹性的策略，值可以是 &amp;ldquo;Auto&amp;rdquo; and &amp;ldquo;Preview&amp;rdquo;.&lt;/li>
&lt;li>Metrics 定义了弹性阈值配置。&lt;/li>
&lt;li>Prediction 定义了预测算法配置。&lt;/li>
&lt;li>PredictionWindowSeconds 指定往后预测多久的数据。&lt;/li>
&lt;/ol>
&lt;h3 id="基于预测的弹性">基于预测的弹性&lt;/h3>
&lt;p>大多数在线应用的负载都有周期性的特征。我们可以根据按天或者按周的趋势预测未来的负载。EHPA 使用 DSP 算法来预测应用未来的时间序列数据。&lt;/p>
&lt;p>以下是一个开启了预测能力的 EHPA 模版例子：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-yaml" data-lang="yaml">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">apiVersion&lt;/span>: &lt;span style="color:#ae81ff">autoscaling.crane.io/v1alpha1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">kind&lt;/span>: &lt;span style="color:#ae81ff">EffectiveHorizontalPodAutoscaler&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">spec&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">prediction&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">predictionWindowSeconds&lt;/span>: &lt;span style="color:#ae81ff">3600&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">predictionAlgorithm&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">algorithmType&lt;/span>: &lt;span style="color:#ae81ff">dsp&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">dsp&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">sampleInterval&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;60s&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">historyLength&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;3d&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="监控数据兜底">监控数据兜底&lt;/h4>
&lt;p>在使用预测算法预测时，你可能会担心预测数据不准带来一定的风险，EHPA 在计算副本数时，不仅会按预测数据计算，同时也会考虑实际监控数据来兜底，提升了弹性的安全性。
实现的原理是当你在 EHPA 中定义 &lt;code>spec.metrics&lt;/code> 并且开启弹性预测时，EffectiveHPAController 会在创建底层管理的 HPA 时按策略自动生成多条 Metric Spec。&lt;/p>
&lt;p>例如，当用户在 EHPA 的 yaml 里定义如下 Metric Spec：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-yaml" data-lang="yaml">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">apiVersion&lt;/span>: &lt;span style="color:#ae81ff">autoscaling.crane.io/v1alpha1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">kind&lt;/span>: &lt;span style="color:#ae81ff">EffectiveHorizontalPodAutoscaler&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">spec&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">metrics&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#f92672">type&lt;/span>: &lt;span style="color:#ae81ff">Resource&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">resource&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">name&lt;/span>: &lt;span style="color:#ae81ff">cpu&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">target&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">type&lt;/span>: &lt;span style="color:#ae81ff">Utilization&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">averageUtilization&lt;/span>: &lt;span style="color:#ae81ff">50&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>它会自动转换成两条 HPA 的阈值配置：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-yaml" data-lang="yaml">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">apiVersion&lt;/span>: &lt;span style="color:#ae81ff">autoscaling/v2beta1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">kind&lt;/span>: &lt;span style="color:#ae81ff">HorizontalPodAutoscaler&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">spec&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">metrics&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#f92672">pods&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">metric&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">name&lt;/span>: &lt;span style="color:#ae81ff">crane_pod_cpu_usage&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">selector&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">matchLabels&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">autoscaling.crane.io/effective-hpa-uid&lt;/span>: &lt;span style="color:#ae81ff">f9b92249-eab9-4671-afe0-17925e5987b8&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">target&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">type&lt;/span>: &lt;span style="color:#ae81ff">AverageValue&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">averageValue&lt;/span>: &lt;span style="color:#ae81ff">100m&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">type&lt;/span>: &lt;span style="color:#ae81ff">Pods&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#f92672">resource&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">name&lt;/span>: &lt;span style="color:#ae81ff">cpu&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">target&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">type&lt;/span>: &lt;span style="color:#ae81ff">Utilization&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">averageUtilization&lt;/span>: &lt;span style="color:#ae81ff">50&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">type&lt;/span>: &lt;span style="color:#ae81ff">Resource&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>在上面这个例子中，用户在 EHPA 创建的 Metric 阈值配置会自动转换成底层 HPA 上的两条 Metric 阈值配置：预测 Metric 阈值和实际监控 Metric 阈值&lt;/p>
&lt;ul>
&lt;li>&lt;strong>预测 Metric 阈值&lt;/strong> 是一个 custom metric。值通过 Crane 的 MetricAdapter 提供。&lt;/li>
&lt;li>&lt;strong>实际监控 Metric 阈值&lt;/strong>是一个 resource metric，它和用户在 EHPA 上定义的一样。这样 HPA 会根据应用实际监控的 Metric 计算副本数。&lt;/li>
&lt;/ul>
&lt;p>HPA 在配置了多个弹性 Metric 阈值时，在计算副本数时会分别计算每条 Metric 对应的副本数，并选择&lt;strong>最大&lt;/strong>的那个副本数作为最终的推荐弹性结果。&lt;/p>
&lt;h4 id="水平弹性的执行流程">水平弹性的执行流程&lt;/h4>
&lt;ol>
&lt;li>EffectiveHPAController 创建 HorizontalPodAutoscaler 和 TimeSeriesPrediction 对象&lt;/li>
&lt;li>PredictionCore 从 prometheus 获取历史 metric 通过预测算法计算，将结果记录到 TimeSeriesPrediction&lt;/li>
&lt;li>HPAController 通过 metric client 从 KubeApiServer 读取 metric 数据&lt;/li>
&lt;li>KubeApiServer 将请求路由到 Crane 的 MetricAdapter。&lt;/li>
&lt;li>HPAController 计算所有的 Metric 返回的结果得到最终的弹性副本推荐。&lt;/li>
&lt;li>HPAController 调用 scale API 对目标应用扩/缩容。&lt;/li>
&lt;/ol>
&lt;p>整体流程图如下：
&lt;img src="/images/crane-ehpa.png" alt="crane-ehpa">&lt;/p>
&lt;h4 id="用户案例">用户案例&lt;/h4>
&lt;p>我们通过一个生产环境的客户案例来介绍 EHPA 的落地效果。&lt;/p>
&lt;p>我们将生产上的数据在预发环境重放，对比使用 EHPA 和社区的 HPA 的弹性效果。&lt;/p>
&lt;p>下图的红线是应用在一天内的实际 CPU 使用量曲线，我们可以看到在8点，12点，晚上8点时是使用高峰。绿线是 EHPA 预测的 CPU 使用量。
&lt;img src="/images/crane-ehpa-metrics-chart.png" alt="craen-ehpa-metrics-chart">&lt;/p>
&lt;p>下图是对应的自动弹性的副本数曲线，红线是社区 HPA 的副本数曲线，绿线是 EHPA 的副本数曲线。
&lt;img src="/images/crane-ehpa-replicas-chart.png" alt="crane-ehpa-metrics-replicas-chart">&lt;/p>
&lt;p>可以看到 EHPA 具有以下优势：&lt;/p>
&lt;ul>
&lt;li>在流量洪峰来临前扩容。&lt;/li>
&lt;li>当流量先降后立刻升时不做无效缩容。&lt;/li>
&lt;li>相比 HPA 更少的弹性次数却更高效。&lt;/li>
&lt;/ul>
&lt;h3 id="scalestrategy-弹性策略">ScaleStrategy 弹性策略&lt;/h3>
&lt;p>EHPA 提供了两种弹性策略：&lt;code>Auto&lt;/code> 和 &lt;code>Preview&lt;/code>。用户可以随时切换它并立即生效。&lt;/p>
&lt;h4 id="auto">Auto&lt;/h4>
&lt;p>Auto 策略下 EHPA 会自动执行弹性行为。默认 EHPA 的策略是 Auto。在这个模式下 EHPA 会创建一个社区的 HPA 对象并自动接管它的生命周期。我们不建议用户修改或者控制这个底层的 HPA 对象，当 EHPA 被删除时，底层的 HPA 对象也会一并删除。&lt;/p>
&lt;h4 id="preview">Preview&lt;/h4>
&lt;p>Preview 策略提供了一种让 EHPA 不自动执行弹性的能力。所以你可以通过 EHPA 的 desiredReplicas 字段观测 EHPA 计算出的副本数。用户可以随时在两个模式间切换，当用户切换到 Preview 模式时，用户可以通过 &lt;code>spec.specificReplicas&lt;/code> 调整应用的副本数，如果 &lt;code>spec.specificReplicas&lt;/code> 为空，则不会对应用执行弹性，但是依然会执行副本数的计算。&lt;/p>
&lt;p>以下是一个配置成 Preview 模式的 EHPA 模版例子：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-yaml" data-lang="yaml">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">apiVersion&lt;/span>: &lt;span style="color:#ae81ff">autoscaling.crane.io/v1alpha1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">kind&lt;/span>: &lt;span style="color:#ae81ff">EffectiveHorizontalPodAutoscaler&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">spec&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">scaleStrategy&lt;/span>: &lt;span style="color:#ae81ff">Preview &lt;/span> &lt;span style="color:#75715e"># ScaleStrategy indicate the strategy to scaling target, value can be &amp;#34;Auto&amp;#34; and &amp;#34;Preview&amp;#34;.&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">specificReplicas&lt;/span>: &lt;span style="color:#ae81ff">5&lt;/span> &lt;span style="color:#75715e"># SpecificReplicas specify the target replicas.&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">status&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">expectReplicas&lt;/span>: &lt;span style="color:#ae81ff">4&lt;/span> &lt;span style="color:#75715e"># expectReplicas is the calculated replicas that based on prediction metrics or spec.specificReplicas.&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">currentReplicas&lt;/span>: &lt;span style="color:#ae81ff">4&lt;/span> &lt;span style="color:#75715e"># currentReplicas is actual replicas from target&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="horizontalpodautoscaler-社区兼容">HorizontalPodAutoscaler 社区兼容&lt;/h3>
&lt;p>EHPA 从设计之出就希望和社区的 HPA 兼容，因为我们不希望重新造一个类似 HPA 的轮子，HPA 在不断演进的过程已经解决了很多通用的问题，EHPA 希望在 HPA 的基础上提供更高阶的 CRD，EHPA 的功能是社区 HPA 的超集。&lt;/p>
&lt;p>EHPA 也会持续跟进支持 HPA 的新功能。&lt;/p>
&lt;h3 id="effectivehorizontalpodautoscaler-status">EffectiveHorizontalPodAutoscaler status&lt;/h3>
&lt;p>EHPA 的 Status 包括了自身的 Status 同时也汇聚了底层 HPA 的部分 Status。&lt;/p>
&lt;p>以下是一个 EHPA 的 Status yaml例子：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-yaml" data-lang="yaml">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">apiVersion&lt;/span>: &lt;span style="color:#ae81ff">autoscaling.crane.io/v1alpha1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">kind&lt;/span>: &lt;span style="color:#ae81ff">EffectiveHorizontalPodAutoscaler&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">status&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">conditions&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#f92672">lastTransitionTime&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;2021-11-30T08:18:59Z&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">message&lt;/span>: &lt;span style="color:#ae81ff">the HPA controller was able to get the target&amp;#39;s current scale&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">reason&lt;/span>: &lt;span style="color:#ae81ff">SucceededGetScale&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">status&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;True&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">type&lt;/span>: &lt;span style="color:#ae81ff">AbleToScale&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#f92672">lastTransitionTime&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;2021-11-30T08:18:59Z&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">message&lt;/span>: &lt;span style="color:#ae81ff">Effective HPA is ready&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">reason&lt;/span>: &lt;span style="color:#ae81ff">EffectiveHorizontalPodAutoscalerReady&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">status&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;True&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">type&lt;/span>: &lt;span style="color:#ae81ff">Ready&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">currentReplicas&lt;/span>: &lt;span style="color:#ae81ff">1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">expectReplicas&lt;/span>: &lt;span style="color:#ae81ff">0&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="cron-based-autoscaling">Cron-based autoscaling&lt;/h3>
&lt;p>EffectiveHorizontalPodAutoscaler 支持基于 cron 的自动缩放。&lt;/p>
&lt;p>除了基于监控指标，有时节假日和工作日的工作负载流量存在差异，简单的预测算法可能效果不佳。然后可以通过设置周末 cron 来支持更大数量的副本来弥补预测的不足。&lt;/p>
&lt;p>对于一些非 web 流量的应用，比如一些应用不需要在周末使用，可以把工作负载的副本数减少到 1，也可以配置 cron 来降低你的服务成本。&lt;/p>
&lt;p>以下是 &lt;code>EHPA Spec&lt;/code> 中的 cron 主要字段：&lt;/p>
&lt;ul>
&lt;li>&lt;code>CronSpec&lt;/code>：可以设置多个 cron 自动伸缩配置，cron cycle 可以设置循环的开始时间和结束时间，并且工作负载的副本数可以在时间范围内持续保持为设定的目标值。&lt;/li>
&lt;li>&lt;code>Name&lt;/code>：cron 标识符&lt;/li>
&lt;li>&lt;code>TargetReplicas&lt;/code>：此 cron 时间范围内工作负载的目标副本数。&lt;/li>
&lt;li>&lt;code>Start&lt;/code>：cron 的开始时间，标准 linux crontab 格式&lt;/li>
&lt;li>&lt;code>End&lt;/code>：cron 的结束时间，标准 linux crontab 格式&lt;/li>
&lt;/ul>
&lt;p>一些云厂商和社区当前的 cron 自动缩放功能存在一些缺点。&lt;/p>
&lt;ol>
&lt;li>cron 能力单独提供，没有在全局视图中进行自动缩放，与 HPA 兼容性差，与其他缩放触发器冲突。&lt;/li>
&lt;li>cron 的语义和行为不是很匹配，使用时甚至很难理解，很容易误导用户，导致自动伸缩失败。&lt;/li>
&lt;/ol>
&lt;p>下图显示了当前 EHPA cron 自动伸缩实现与其他 cron 能力的对比。&lt;/p>
&lt;p>&lt;img src="/images/crane-keda-ali-compare-cron.png" alt="crane-keda-ali-compare-cron.png">&lt;/p>
&lt;p>针对以上问题，EHPA 实现的 cron autoscaling 是在与 HPA 兼容的基础上设计的，cron 作为 HPA 的一个指标，与其他指标一起作用于工作负载。&lt;/p>
&lt;p>另外，cron 的设置也很简单。单独配置 cron 时，不在活动时间范围内时，不会对工作负载执行缩放。&lt;/p>
&lt;h4 id="cron-working-without-other-metrics">Cron working without other metrics&lt;/h4>
&lt;p>假设你没有配置其他指标，你只需配置 cron 本身即可工作。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-yaml" data-lang="yaml">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">apiVersion&lt;/span>: &lt;span style="color:#ae81ff">autoscaling.crane.io/v1alpha1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">kind&lt;/span>: &lt;span style="color:#ae81ff">EffectiveHorizontalPodAutoscaler&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">metadata&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">name&lt;/span>: &lt;span style="color:#ae81ff">php-apache-local&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">spec&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e"># ScaleTargetRef 关联到需扩缩容的工作负载&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">scaleTargetRef&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">apiVersion&lt;/span>: &lt;span style="color:#ae81ff">apps/v1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">kind&lt;/span>: &lt;span style="color:#ae81ff">Deployment&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">name&lt;/span>: &lt;span style="color:#ae81ff">php-apache&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">minReplicas: 1 # MinReplicas &lt;/span>: &lt;span style="color:#ae81ff">autoscaler 缩放的最低副本数&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">maxReplicas: 100 # MaxReplicas &lt;/span>: &lt;span style="color:#ae81ff">autoscaler 缩放的最大副本数 &lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">scaleStrategy: Auto # ScaleStrategy &lt;/span>: &lt;span style="color:#ae81ff">缩放工作负载时候，所采用的策略。可选值为 &amp;#34;Auto&amp;#34; &amp;#34;Manual&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e"># 最好将Cron Scheduling设置为一个完整的时间周期，例如： 一天，一周&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e"># 下面是一天的Cron Scheduling&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">#(targetReplicas)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">#80 -------- --------- ----------&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e"># | | | | | |&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">#10 ------------ ----- -------- ----------&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">#(time) 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">#本地时区(timezone: &amp;#34;Local&amp;#34;)意味着您使用运行Craned所在的服务器（或者可能是容器）的时区。例如，当Craned 是以UTC时区开始，那么它就是UTC。如果一开始是Asia/Shanghai，那么它就是Asia/Shanghai。&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">crons&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#f92672">name&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;cron1&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">timezone&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;Local&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">description&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;scale down&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">start&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;0 0 ? * *&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">end&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;0 6 ? * *&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">targetReplicas&lt;/span>: &lt;span style="color:#ae81ff">10&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#f92672">name&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;cron2&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">timezone&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;Local&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">description&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;scale up&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">start&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;0 6 ? * *&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">end&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;0 9 ? * *&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">targetReplicas&lt;/span>: &lt;span style="color:#ae81ff">80&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#f92672">name&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;cron3&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">timezone&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;Local&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">description&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;scale down&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">start&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;00 9 ? * *&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">end&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;00 11 ? * *&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">targetReplicas&lt;/span>: &lt;span style="color:#ae81ff">10&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#f92672">name&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;cron4&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">timezone&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;Local&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">description&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;scale up&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">start&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;00 11 ? * *&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">end&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;00 14 ? * *&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">targetReplicas&lt;/span>: &lt;span style="color:#ae81ff">80&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#f92672">name&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;cron5&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">timezone&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;Local&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">description&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;scale down&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">start&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;00 14 ? * *&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">end&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;00 17 ? * *&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">targetReplicas&lt;/span>: &lt;span style="color:#ae81ff">10&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#f92672">name&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;cron6&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">timezone&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;Local&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">description&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;scale up&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">start&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;00 17 ? * *&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">end&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;00 20 ? * *&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">targetReplicas&lt;/span>: &lt;span style="color:#ae81ff">80&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#f92672">name&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;cron7&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">timezone&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;Local&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">description&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;scale down&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">start&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;00 20 ? * *&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">end&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;00 00 ? * *&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">targetReplicas&lt;/span>: &lt;span style="color:#ae81ff">10&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>CronSpec 具有以下字段:&lt;/p>
&lt;ul>
&lt;li>&lt;strong>name&lt;/strong> 定义了 cron 的名字，cron 名字在同一个 Ehpa 中必须是唯一的&lt;/li>
&lt;li>&lt;strong>description&lt;/strong> 定义 cron 的详细描述。它可以是空的。&lt;/li>
&lt;li>&lt;strong>timezone&lt;/strong> 定义Crane所要调度的 cron 时区。如果未指定，则默认使用&lt;code>UTC&lt;/code>时区。你可以将它设置为&lt;code>Local&lt;/code>，这将使用正在运行的Crane容器所在的时区。其实，你定义&lt;code>America/Los_Angeles&lt;/code>也是可以的。&lt;/li>
&lt;li>&lt;strong>start&lt;/strong> 定义 cron 开始调度的时间，是 crontab 格式。参考 &lt;a href="https://en.wikipedia.org/wiki/Cron">wiki-Cron&lt;/a>&lt;/li>
&lt;li>&lt;strong>end&lt;/strong> 定义 cron 结束调度的时间，是 crontab 格式。参考 &lt;a href="https://en.wikipedia.org/wiki/Cron">wiki-Cron&lt;/a>&lt;/li>
&lt;li>&lt;strong>targetReplicas&lt;/strong> 定义目标副本在 cron 处于活动状态时要扩展的工作负载，这意味着目标副本数介于开始时间和结束时间之间生效。&lt;/li>
&lt;/ul>
&lt;p>以上YAML定义，意味着一天当中，工作负载在每小时所需要保持的副本数。工作负载将会每天按照该规则执行。&lt;/p>
&lt;pre tabindex="0">&lt;code> #80 -------- --------- ----------
# | | | | | |
#1 ------------ ----- -------- ----------
#(time) 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23
&lt;/code>&lt;/pre>&lt;p>记住&lt;strong>不要设置开始时间在结束时间之后&lt;/strong>。&lt;/p>
&lt;p>例如，当你设置以下内容时：&lt;/p>
&lt;pre tabindex="0">&lt;code> crons:
- name: &amp;#34;cron2&amp;#34;
timezone: &amp;#34;Local&amp;#34;
description: &amp;#34;scale up&amp;#34;
start: &amp;#34;0 9 ? * *&amp;#34;
end: &amp;#34;0 6 ? * *&amp;#34;
targetReplicas: 80
&lt;/code>&lt;/pre>&lt;p>以上无效，因为开始总是晚于结束。&lt;/p>
&lt;p>HPA 控制器始终根据工作负载所描述的副本数进行扩展，这意味着保留原有副本数不变。&lt;/p>
&lt;h4 id="horizontal-scaling-process">Horizontal scaling process&lt;/h4>
&lt;p>cron 驱动和扩展过程有六个步骤：&lt;/p>
&lt;ol>
&lt;li>&lt;code>EffectiveHPAController&lt;/code> 创建 &lt;code>HorizontalPodAutoscaler&lt;/code>，它被注入到&lt;code>spec&lt;/code>中的&lt;code>external cron metrics&lt;/code>中。&lt;/li>
&lt;li>&lt;code>HPAController&lt;/code> 从 &lt;code>KubeApiServer&lt;/code> 读取 &lt;code>external cron metrics&lt;/code>&lt;/li>
&lt;li>&lt;code>KubeApiServer&lt;/code> 将请求转发给 &lt;code>MetricAdapter&lt;/code> 和 &lt;code>MetricServer&lt;/code>&lt;/li>
&lt;li>&lt;code>MetricAdapter&lt;/code> 找到目标 hpa 的 &lt;code>cron scaler&lt;/code>，并检测 &lt;code>cron scaler&lt;/code> 是否处于活动状态。这意味着当前时间介于 cron 开始和结束计划时间之间。它将返回&lt;code>TargetReplicas&lt;/code>中定义的&lt;code>CronSpec&lt;/code>。&lt;/li>
&lt;li>&lt;code>HPAController&lt;/code> 计算所有 metrics 结果，并通过选择最大的一个为目标副本数。并由此创建一个新的&lt;code>scale replicas&lt;/code>。&lt;/li>
&lt;li>&lt;code>HPAController&lt;/code> 使用 &lt;code>Scale Api&lt;/code> 缩放目标&lt;/li>
&lt;/ol>
&lt;p>使用 EHPA 时，用户可以只配置 cron metric，让 EHPA 用作 cron hpa。&lt;/p>
&lt;p>一个 EHPA 的多个 crons 将转换为一个&lt;code>external metrics&lt;/code>。&lt;/p>
&lt;p>HPA 将获取&lt;code>external metrics&lt;/code>并在协调时计算目标副本。当存在多个指标的工作负载时，HPA 将选择最大的副本数来扩展。&lt;/p>
&lt;h4 id="cron-working-with-other-metrics-together">Cron working with other metrics together&lt;/h4>
&lt;p>&lt;code>EffectiveHorizontalPodAutoscaler&lt;/code> 兼容 &lt;code>HorizontalPodAutoscaler&lt;/code>（内置在 kubernetes）。因此，如果你为 HPA 配置了指标，例如 cpu 或内存，那么 HPA 将根据它观察到的实时指标对副本数进行扩展。&lt;/p>
&lt;p>通过 EHPA，用户可以同时配置 &lt;code>CronMetric&lt;/code>、&lt;code>PredictionMetric&lt;/code>、&lt;code>OriginalMetric&lt;/code>。&lt;/p>
&lt;p>&lt;strong>我们强烈建议你配置所有维度的指标。它们分别代表 cron 副本、先前预测的副本、后观察的副本。&lt;/strong>&lt;/p>
&lt;p>这是一个强大的功能。因为 HPA 总是选择由所有维度&lt;code>metrics&lt;/code>计算的最大副本进行扩展。&lt;/p>
&lt;p>这将保证你工作负载的 QOS，当你同时配置三种类型的自动缩放时，根据实际观察到的指标计算的副本最大，然后它将使用最大的一个。&lt;/p>
&lt;p>尽管由于某些意想不到的原因，导致由&lt;code>PredictionMetric&lt;/code>计算的副本更小。因此，你不必担心 QOS。&lt;/p>
&lt;h4 id="mechanism">Mechanism&lt;/h4>
&lt;p>当&lt;code>metrics adapter&lt;/code>处理&lt;code>external cron metrics&lt;/code>请求时，&lt;code>metrics adapter&lt;/code>将执行以下步骤。&lt;/p>
&lt;pre tabindex="0">&lt;code class="language-mermaid" data-lang="mermaid">graph LR
A[Start] --&amp;gt; B{Active Cron?};
B --&amp;gt;|Yes| C(largest targetReplicas) --&amp;gt; F;
B --&amp;gt;|No| D{Work together with other metrics?};
D --&amp;gt;|Yes| G(minimum replicas) --&amp;gt; F;
D --&amp;gt;|No| H(current replicas) --&amp;gt; F;
F[Result workload replicas];
&lt;/code>&lt;/pre>&lt;ol>
&lt;li>
&lt;p>没有活跃的cron，有两种情况：&lt;/p>
&lt;ul>
&lt;li>没有其他 hpa 指标与 cron 一起使用，然后返回当前工作负载副本以保留原始所需的副本&lt;/li>
&lt;li>当其他 hpa 指标与 cron 一起使用，将会返回最小值以消除cron对其他指标的影响。当 cron 与其他指标一起工作时，它不应该返回工作负载的原始副本数，因为可能有其他指标想要缩小工作负载的副本数。&lt;code>HPA Controller&lt;/code>选择由所有指标计算的最大副本（这是硬代码中的 hpa 默认策略)，cron 会影响 hpa。所以我们应该在 cron 不活动时移除 cron 效果，它应该返回最小值。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>有活跃的cron。我们使用&lt;code>cron spec&lt;/code>中指定的最大目标副本。基本上，在同一时间段内不应有超过一个活跃的 cron，这不是最佳实践。&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p>HPA 将获取&lt;code>cron external metrics&lt;/code>，然后它会自行计算副本数。&lt;/p>
&lt;h4 id="use-case">Use Case&lt;/h4>
&lt;p>当你需要在午夜将工作负载副本数保持在最低限度，根据该需求配置了 cron。&lt;/p>
&lt;p>你需要 HPA 来获取指标服务器观察到的真实指标，以根据实时观察到的指标进行扩展。&lt;/p>
&lt;p>最后，你配置一个&lt;code>prediction-driven metric&lt;/code>，通过预测方式提前扩大规模并在末期缩小规模。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-yaml" data-lang="yaml">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">apiVersion&lt;/span>: &lt;span style="color:#ae81ff">autoscaling.crane.io/v1alpha1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">kind&lt;/span>: &lt;span style="color:#ae81ff">EffectiveHorizontalPodAutoscaler&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">metadata&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">name&lt;/span>: &lt;span style="color:#ae81ff">php-apache-multi-dimensions&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">spec&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e"># ScaleTargetRef 关联到需扩缩容的工作负载&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">scaleTargetRef&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">apiVersion&lt;/span>: &lt;span style="color:#ae81ff">apps/v1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">kind&lt;/span>: &lt;span style="color:#ae81ff">Deployment&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">name&lt;/span>: &lt;span style="color:#ae81ff">php-apache&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">minReplicas: 1 # MinReplicas &lt;/span>: &lt;span style="color:#ae81ff">缩放的最小副本数&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">maxReplicas: 100 # MaxReplicas &lt;/span>: &lt;span style="color:#ae81ff">缩放的最大副本数 &lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">scaleStrategy: Auto # ScaleStrategy &lt;/span>: &lt;span style="color:#ae81ff">缩放工作负载时候，所采用的策略。可选值为 &amp;#34;Auto&amp;#34; &amp;#34;Manual&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e"># Metrics 包含了用于计算所需副本数的指标。&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">metrics&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#f92672">type&lt;/span>: &lt;span style="color:#ae81ff">Resource&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">resource&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">name&lt;/span>: &lt;span style="color:#ae81ff">cpu&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">target&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">type&lt;/span>: &lt;span style="color:#ae81ff">Utilization&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">averageUtilization&lt;/span>: &lt;span style="color:#ae81ff">50&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e"># Prediction 的配置定义了需要预测的资源&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e"># 若不配置，则默认不启动 prediction&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">prediction&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">predictionWindowSeconds&lt;/span>: &lt;span style="color:#ae81ff">3600&lt;/span> &lt;span style="color:#75715e"># PredictionWindowSeconds 是预测未来指标的时间窗口。&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">predictionAlgorithm&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">algorithmType&lt;/span>: &lt;span style="color:#ae81ff">dsp&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">dsp&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">sampleInterval&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;60s&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">historyLength&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;3d&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">crons&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#f92672">name&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;cron1&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">description&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;scale up&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">start&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;0 0 ? * 6&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">end&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;00 23 ? * 0&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">targetReplicas&lt;/span>: &lt;span style="color:#ae81ff">100&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="常见问题">常见问题&lt;/h2>
&lt;h3 id="错误-unable-to-get-metric-crane_pod_cpu_usage">错误: unable to get metric crane_pod_cpu_usage&lt;/h3>
&lt;p>当你查看 EffectiveHorizontalPodAutoscaler 的 Status 时，可以会看到这样的错误：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-yaml" data-lang="yaml">&lt;span style="display:flex;">&lt;span>- &lt;span style="color:#f92672">lastTransitionTime&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;2022-05-15T14:05:43Z&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">message: &amp;#39;the HPA was unable to compute the replica count&lt;/span>: &lt;span style="color:#ae81ff">unable to get metric&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">crane_pod_cpu_usage: unable to fetch metrics from custom metrics API&lt;/span>: &lt;span style="color:#ae81ff">TimeSeriesPrediction&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">is not ready. &amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">reason&lt;/span>: &lt;span style="color:#ae81ff">FailedGetPodsMetric&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">status&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;False&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">type&lt;/span>: &lt;span style="color:#ae81ff">ScalingActive&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>原因：不是所有的工作负载的 CPU 使用率都是可预测的，当无法预测时就会显示以上错误。&lt;/p>
&lt;p>解决方案：&lt;/p>
&lt;ul>
&lt;li>等一段时间再看。预测算法 &lt;code>DSP&lt;/code> 需要一定时间的数据才能进行预测。希望了解算法细节的可以查看算法的文档。&lt;/li>
&lt;li>EffectiveHorizontalPodAutoscaler 提供一种保护机制，当预测失效时依然能通过实际的 CPU 使用率工作。&lt;/li>
&lt;/ul></description></item><item><title>Docs: TimeSeriesPrediction</title><link>/zh-cn/docs/tutorials/using-time-series-prediction/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/zh-cn/docs/tutorials/using-time-series-prediction/</guid><description>
&lt;p>Knowing the future makes things easier for us.&lt;/p>
&lt;hr>
&lt;p>许多业务在时间序列上天然存在周期性的，尤其是对于那些直接或间接为“人”服务的业务。这种周期性是由人们日常活动的规律性决定的。例如，人们习惯于中午和晚上点外卖；早晚总有交通高峰；即使是搜索等模式不那么明显的服务，夜间的请求量也远低于白天时间。对于这类业务相关的应用来说，从过去几天的历史数据中推断出次日的指标，或者从上周一的数据中推断出下周一的访问量是很自然的想法。通过预测未来 24 小时内的指标或流量模式，我们可以更好地管理我们的应用程序实例，稳定我们的系统，同时降低成本。&lt;/p>
&lt;p>&lt;code>TimeSeriesPrediction&lt;/code> 被用于预测 Kubernetes 对象指标。它基于 &lt;code>PredictionCore&lt;/code> 进行预测。&lt;/p>
&lt;h2 id="features">Features&lt;/h2>
&lt;p>&lt;code>TimeSeriesPrediction&lt;/code> 的示例 yaml 如下所示：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-yaml" data-lang="yaml">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">apiVersion&lt;/span>: &lt;span style="color:#ae81ff">prediction.crane.io/v1alpha1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">kind&lt;/span>: &lt;span style="color:#ae81ff">TimeSeriesPrediction&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">metadata&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">name&lt;/span>: &lt;span style="color:#ae81ff">node-resource-percentile&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">namespace&lt;/span>: &lt;span style="color:#ae81ff">default&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">spec&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">targetRef&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">kind&lt;/span>: &lt;span style="color:#ae81ff">Node&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">name&lt;/span>: &lt;span style="color:#ae81ff">192.168.56.166&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">predictionWindowSeconds&lt;/span>: &lt;span style="color:#ae81ff">600&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">predictionMetrics&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#f92672">resourceIdentifier&lt;/span>: &lt;span style="color:#ae81ff">node-cpu&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">type&lt;/span>: &lt;span style="color:#ae81ff">ResourceQuery&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">resourceQuery&lt;/span>: &lt;span style="color:#ae81ff">cpu&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">algorithm&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">algorithmType&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;percentile&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">percentile&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">sampleInterval&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;1m&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">minSampleWeight&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;1.0&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">histogram&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">maxValue&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;10000.0&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">epsilon&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;1e-10&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">halfLife&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;12h&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">bucketSize&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;10&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">firstBucketSize&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;40&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">bucketSizeGrowthRatio&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;1.5&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#f92672">resourceIdentifier&lt;/span>: &lt;span style="color:#ae81ff">node-mem&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">type&lt;/span>: &lt;span style="color:#ae81ff">ResourceQuery&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">resourceQuery&lt;/span>: &lt;span style="color:#ae81ff">memory&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">algorithm&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">algorithmType&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;percentile&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">percentile&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">sampleInterval&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;1m&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">minSampleWeight&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;1.0&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">histogram&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">maxValue&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;1000000.0&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">epsilon&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;1e-10&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">halfLife&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;12h&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">bucketSize&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;10&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">firstBucketSize&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;40&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">bucketSizeGrowthRatio&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;1.5&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>&lt;code>spec.targetRef&lt;/code> 定义了对 Kubernetes 对象的引用，包括 Node 或其他工作负载，例如 Deployment。&lt;/li>
&lt;li>&lt;code>spec.predictionMetrics&lt;/code> 定义了关于 &lt;code>spec.targetRef&lt;/code> 的指标。&lt;/li>
&lt;li>&lt;code>spec.predictionWindowSeconds&lt;/code> 是预测时间序列持续时间。&lt;code>TimeSeriesPredictionController&lt;/code> 将轮换 &lt;code>spec.Status&lt;/code> 中的预测数据，以供消费者使用预测的时间序列数据。&lt;/li>
&lt;/ul>
&lt;h2 id="prediction-metrics">Prediction Metrics&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-yaml" data-lang="yaml">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">apiVersion&lt;/span>: &lt;span style="color:#ae81ff">prediction.crane.io/v1alpha1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">kind&lt;/span>: &lt;span style="color:#ae81ff">TimeSeriesPrediction&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">metadata&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">name&lt;/span>: &lt;span style="color:#ae81ff">node-resource-percentile&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">namespace&lt;/span>: &lt;span style="color:#ae81ff">default&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">spec&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">predictionMetrics&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#f92672">resourceIdentifier&lt;/span>: &lt;span style="color:#ae81ff">node-cpu&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">type&lt;/span>: &lt;span style="color:#ae81ff">ResourceQuery&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">resourceQuery&lt;/span>: &lt;span style="color:#ae81ff">cpu&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">algorithm&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">algorithmType&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;percentile&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">percentile&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">sampleInterval&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;1m&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">minSampleWeight&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;1.0&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">histogram&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">maxValue&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;10000.0&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">epsilon&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;1e-10&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">halfLife&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;12h&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">bucketSize&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;10&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">firstBucketSize&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;40&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">bucketSizeGrowthRatio&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;1.5&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="metric-type">Metric Type&lt;/h3>
&lt;p>现在我们只支持 &lt;code>prometheus&lt;/code> 作为数据源。我们定义&lt;code>MetricType&lt;/code>与数据源进行结合。但是现在可能有些数据源不支持 &lt;code>MetricType&lt;/code>。&lt;/p>
&lt;p>指标查询有以下三种类型：&lt;/p>
&lt;ul>
&lt;li>&lt;code>ResourceQuery&lt;/code>是 kubernetes 内置的资源指标，例如 cpu 或 memory。Crane目前只支持 CPU 和内存。&lt;/li>
&lt;li>&lt;code>RawQuery&lt;/code>是通过 DSL 的查询，比如 prometheus 查询语句。现在已支持 Prometheus 。&lt;/li>
&lt;li>&lt;code>ExpressionQuery&lt;/code>是一个表达式查询。&lt;/li>
&lt;/ul>
&lt;h3 id="algorithm">Algorithm&lt;/h3>
&lt;p>&lt;code>Algorithm&lt;/code>定义算法类型和参数来预测指标。现在有两种算法：&lt;/p>
&lt;ul>
&lt;li>&lt;code>dsp&lt;/code>是一种预测时间序列的算法，它基于 FFT（快速傅里叶变换），擅长预测一些具有季节性和周期的时间序列。&lt;/li>
&lt;li>&lt;code>percentile&lt;/code>是一种估计时间序列，并找到代表过去时间序列的推荐值的算法，它基于指数衰减权重直方图统计。它是用来估计一个时间序列的，它不擅长预测一个时间序列，虽然&lt;code>percentile&lt;/code>可以输出一个时间序列的预测数据，但是都是一样的值。&lt;strong>所以如果你想预测一个时间序列，dsp 是一个更好的选择。&lt;/strong>&lt;/li>
&lt;/ul></description></item></channel></rss>